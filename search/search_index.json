{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"Rye: a Hassle-Free Python Experience <p>Note</p> <p>If you're getting started with Rye, consider uv, the successor project from the same maintainers.</p> <p>While Rye is actively maintained, uv offers a more stable and feature-complete experience, and is the recommended choice for new projects.</p> <p>Having trouble migrating? Let us know what's missing.</p> <p>Rye is a comprehensive project and package management solution for Python. Born from its creator's desire to establish a one-stop-shop for all Python users, Rye provides a unified experience to install and manages Python installations, <code>pyproject.toml</code> based projects, dependencies and virtualenvs seamlessly.  It's designed to accommodate complex projects, monorepos and to facilitate global tool installations.  Curious? Watch an introduction.</p> <p>A hassle-free experience for Python developers at every level.</p> <p> Star Discuss Sponsor </p> <p>Installation Instructions</p> LinuxmacOSWindowsCompile Yourself <p>To install you can run a curl command which will install the right binary for your operating system and CPU architecture and install it:</p> <pre><code>curl -sSf https://rye.astral.sh/get | bash\n</code></pre> <p>Alternatively if you don't trust this approach, you can download the latest release binary.  On first run it will install itself.</p> <ul> <li>rye-x86_64-linux.gz Intel/AMD (x86-64).</li> <li>rye-aarch64-linux.gz for ARM64.</li> </ul> <pre><code>gunzip rye-x86_64-linux.gz\nchmod +x ./rye-x86_64-linux\n./rye-x86_64-linux\n</code></pre> <p>To install you can run a curl command which will install the right binary for your operating system and CPU architecture and install it:</p> <pre><code>curl -sSf https://rye.astral.sh/get | bash\n</code></pre> <p>Alternatively if you don't trust this approach, you can download the latest release binary.  On first run it will install itself.</p> <ul> <li>rye-aarch64-macos.gz for Apple Silicon (M1/M2/M3) (ARM64).</li> <li>rye-x86_64-macos.gz for Intel processors (x86-64).</li> </ul> <pre><code>gunzip rye-aarch64-macos.gz\nchmod +x ./rye-aarch64-macos\n./rye-aarch64-macos\n</code></pre> <p>To install Rye on windows download the latest release and run the binary.  Upon first run it will install itself.  Please note that it's strongly recommended to have \"Developer Mode\" activated when using Rye and before starting the installation.  Learn more.</p> <ul> <li>rye-x86_64-windows.exe for 64-bit (x86-64).</li> <li>rye-x86-windows.exe for 32-bit (x86).</li> </ul> <p>Note</p> <p>Rye does not yet use signed binaries which means that you will need to allow the execution of the downloaded executable.  If there is no obvious way to do so, click on \"More info\" on the error message that shows up and then on \"Run anyway\".</p> <p>Additionally sometimes a Trojan warning about \"Bearfoos\" is shown.  This is a false positive.  For more information see the discussion Windows Bearfoos virus associated with rye.</p> <p>You need to have Rust and Cargo installed.  If you don't have, you can use rustup to get them onto your machine.</p> <p>Afterwards you can install <code>Rye</code> via <code>cargo</code>:</p> <pre><code>cargo install --git https://github.com/astral-sh/rye rye\n</code></pre> <p>For the next steps or ways to customize the installation, head over to the detailed installation guide.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Here you can find all the released changes to Rye.  If you want to also see the in-development changes that were not released yet, refer to the CHANGELOG.md file in the repository.</p>"},{"location":"changelog/#0440","title":"0.44.0","text":"<p>Released on 2025-02-26.</p> <ul> <li>Upgrade runners to <code>macos-14</code> by @charliermarsh in https://github.com/astral-sh/rye/pull/1443</li> <li>Bump bundled Ruff version to 0.9.6 by @catwell in https://github.com/astral-sh/rye/pull/1457</li> <li>Set Rust toolchain in <code>rust-toolchain.toml</code> by @charliermarsh in https://github.com/astral-sh/rye/pull/1460</li> <li>Bump bundled uv version to v0.6.3 by @github-actions in https://github.com/astral-sh/rye/pull/1445</li> </ul>"},{"location":"changelog/#0430","title":"0.43.0","text":"<p>Released on 2024-12-09.</p> <ul> <li>Fix compatible toolchain to allow Python 3.13 by @PushUpek in https://github.com/astral-sh/rye/pull/1429</li> <li>Ignore free-threaded CPython builds by @Alexis-D in https://github.com/astral-sh/rye/pull/1437</li> <li>Bump bundled Ruff version to v0.8.2 by @charliermarsh in https://github.com/astral-sh/rye/pull/1440</li> <li>Add support for Python 3.9.21, 3.10.16, 3.11.11, 3.12.8, and 3.13.1 by @github-actions in https://github.com/astral-sh/rye/pull/1439</li> <li>Upgrade bundled uv version to v0.5.7 by @github-actions in https://github.com/astral-sh/rye/pull/1424</li> </ul>"},{"location":"changelog/#0420","title":"0.42.0","text":"<p>Released on 2024-10-21.</p> <ul> <li>Sync Python Releases by @github-actions in https://github.com/astral-sh/rye/pull/1406</li> <li>Bump bundled Ruff version to v0.7.0 by @charliermarsh in https://github.com/astral-sh/rye/pull/1419</li> <li>Bump bundled uv version to v0.4.25 by @github-actions in https://github.com/astral-sh/rye/pull/1405</li> </ul>"},{"location":"changelog/#0410","title":"0.41.0","text":"<p>Released on 2024-09-29.</p> <ul> <li>Restore hash annotations in lockfile by @charliermarsh in https://github.com/astral-sh/rye/pull/1403</li> <li>Upgrade bundled uv version to v0.4.17 by @github-actions in https://github.com/astral-sh/rye/pull/1393</li> </ul>"},{"location":"changelog/#0400","title":"0.40.0","text":"<p>Released on 2024-09-22.</p> <ul> <li>Remove pip-tools support; use uv for all operations by @nazq in https://github.com/astral-sh/rye/pull/1226</li> <li>Respect exclusions when generating hashes by @charliermarsh in https://github.com/astral-sh/rye/pull/1357</li> <li>List all existing tool references on <code>rye toolchain remove</code> by @soof-golan in https://github.com/astral-sh/rye/pull/1346</li> <li>Fix a few regex inefficiencies by @InSyncWithFoo in https://github.com/astral-sh/rye/pull/1326</li> <li>Never modify or delete the virtualenv in <code>rye list</code> by @bluss in https://github.com/astral-sh/rye/pull/1351</li> <li>Use <code>inspect_err</code> over <code>map_err</code> by @charliermarsh in https://github.com/astral-sh/rye/pull/1385</li> <li>Upgrade bundled Python releases by @github-actions in https://github.com/astral-sh/rye/pull/1379</li> <li>Upgrade bundled uv version to v0.4.15 by @github-actions in https://github.com/astral-sh/rye/pull/1388</li> <li>Update bundled Ruff version to v0.6.7 by @charliermarsh in https://github.com/astral-sh/rye/pull/1389</li> </ul>"},{"location":"changelog/#0390","title":"0.39.0","text":"<p>Released on 2024-08-20.</p> <ul> <li>Update Cargo dependencies by @charliermarsh in https://github.com/astral-sh/rye/pull/1310</li> <li>Fix typo in <code>add.md</code> by @mikkelam in https://github.com/astral-sh/rye/pull/1322</li> <li>Fix typo in FAQ by @toadjaune in https://github.com/astral-sh/rye/pull/1330</li> <li>Update Python releases to include Python 3.12.4 by @github-actions in https://github.com/astral-sh/rye/pull/1336</li> <li>Update bundled uv version to <code>v0.3.0</code> by @github-actions in https://github.com/astral-sh/rye/pull/1332</li> </ul>"},{"location":"changelog/#0380","title":"0.38.0","text":"<p>Released on 2024-08-01.</p> <ul> <li>Fix <code>rye add</code> and <code>rye remove</code> to create proper <code>tool.rye</code> section for <code>--dev</code> and <code>--exclude</code> flags by @flyaroundme in https://github.com/astral-sh/rye/pull/1256</li> <li>Fix <code>uninstall_cmd</code> on Windows by @250h in https://github.com/astral-sh/rye/pull/1153</li> <li>Make rye run print script list to stdout by @mitsuhiko in https://github.com/astral-sh/rye/pull/1268</li> <li>Always write <code>--index-url</code> before <code>--extra-index-url</code> by @charliermarsh in https://github.com/astral-sh/rye/pull/1278</li> <li>Use case-insensitive comparison for detecting <code>rye.exe</code> by @charliermarsh in https://github.com/astral-sh/rye/pull/1286</li> <li>Update Python releases to include stripped variants by @github-actions in https://github.com/astral-sh/rye/pull/1280</li> <li>Fix documentation for readline license by @3w36zj6 in https://github.com/astral-sh/rye/pull/1297</li> <li>Update bundled uv version to <code>v0.2.33</code> by @github-actions in https://github.com/astral-sh/rye/pull/1303</li> <li>Update bundled pip to <code>v24.2.0</code> by @charliermarsh in https://github.com/astral-sh/rye/pull/1304</li> </ul>"},{"location":"changelog/#0370","title":"0.37.0","text":"<p>Released on 2024-07-20.</p> <ul> <li>Fix verify-ssl option parsing by @taki-d in https://github.com/astral-sh/rye/pull/1208</li> <li>Emit warning when asked to build a virtual project by @nazq in https://github.com/astral-sh/rye/pull/1227</li> <li>Add short version <code>-d</code> for <code>rye remove --dev</code> by @nikhilweee in https://github.com/astral-sh/rye/pull/1239</li> <li>Remove redundant alias information from CLI by @piotrgredowski in https://github.com/astral-sh/rye/pull/1237</li> <li>Update bundled uv version to <code>v0.2.27</code> by @github-actions in https://github.com/astral-sh/rye/pull/1232</li> <li>Update Python releases to include <code>3.12.4</code> by @github-actions in https://github.com/astral-sh/rye/pull/1230</li> <li>Respect <code>.python-version</code> in Rye builds by @charliermarsh in https://github.com/astral-sh/rye/pull/1250</li> <li>Update bundled Ruff version to <code>v0.5.4</code> by @charliermarsh in https://github.com/astral-sh/rye/pull/1251</li> </ul>"},{"location":"changelog/#0360","title":"0.36.0","text":"<p>Released on 2024-07-07.</p> <ul> <li>Upgrade pyyaml to v6.0.1 by @charliermarsh in https://github.com/astral-sh/rye/pull/1170</li> <li>Pass keyring-provider to uv sync and install by @emarsden-iso in https://github.com/astral-sh/rye/pull/1183</li> <li>Add docs hint for packages on multiple indexes by @dennisrall in https://github.com/astral-sh/rye/pull/1188</li> <li>Pass universal flag down to uv by @lbowenwest in https://github.com/astral-sh/rye/pull/1186</li> <li>Use musl build for ARM Linux by @charliermarsh in https://github.com/astral-sh/rye/pull/1192</li> <li>Bump uv to 0.2.22 by @charliermarsh in https://github.com/astral-sh/rye/pull/1192</li> <li>Upgrade twine to v5.1.1 by @charliermarsh in https://github.com/astral-sh/rye/pull/1199</li> </ul>"},{"location":"changelog/#0350","title":"0.35.0","text":"<p>Released on 2024-06-24.</p> <ul> <li>Enforce <code>--pre</code> when auto-syncing by @charliermarsh in https://github.com/astral-sh/rye/pull/1107</li> <li>Move from <code>rye-up.com</code> to <code>rye.astral.sh</code> by @charliermarsh in https://github.com/astral-sh/rye/pull/1113</li> <li>Fix install instructions on README.md for mac/linux by @timothycrosley in https://github.com/astral-sh/rye/pull/1114</li> <li>Fix CLI deserialization of PowerShell (<code>powershell</code>) by @charliermarsh in https://github.com/astral-sh/rye/pull/1125</li> <li>Add ability to specify option to generate hashes within pyproject.toml by @asmith26 in https://github.com/astral-sh/rye/pull/1129</li> <li>Bump uv to 0.2.13 by @charliermarsh in https://github.com/astral-sh/rye/pull/1123</li> <li>Improve <code>config.toml</code> error messages by @zys864 in https://github.com/astral-sh/rye/pull/1155</li> </ul>"},{"location":"changelog/#0340","title":"0.34.0","text":"<p>Released on 2024-05-20.</p> <ul> <li>Add nushell completion support by @MilesCranmer in https://github.com/astral-sh/rye/pull/1030</li> <li>Use uv in rye build when enabled by @bluss in https://github.com/astral-sh/rye/pull/978</li> <li>Add short version add -d for rye add --dev by @bluss in https://github.com/astral-sh/rye/pull/1044</li> <li>Flip uv to the default Rye backend by @charliermarsh in https://github.com/astral-sh/rye/pull/1053</li> <li>Fix Rye not using user-chosen toolchain as default during installation by @pjdon in https://github.com/astral-sh/rye/pull/1054</li> <li>Add keyring support for uv by @emarsden-iso in https://github.com/astral-sh/rye/pull/1016</li> <li>Allow to generate lockfiles with hashes when using uv by @mvaled in https://github.com/astral-sh/rye/pull/1070</li> <li>Bump ruff to 0.4.4 by @davfsa in https://github.com/astral-sh/rye/pull/1075</li> <li>Fix TOML array formatting by @my1e5 in https://github.com/astral-sh/rye/pull/1084</li> <li>Bump uv to 0.1.44 by @charliermarsh in https://github.com/astral-sh/rye/pull/1085</li> <li>Discover cosmo-ified (<code>.com</code>) binaries on Windows by @mataha in https://github.com/astral-sh/rye/pull/1091</li> <li>Write <code>use-uv = true</code> in no-prompt mode by @charliermarsh in https://github.com/astral-sh/rye/pull/1098</li> </ul>"},{"location":"changelog/#0330","title":"0.33.0","text":"<p>Released on 2024-04-24.</p> <ul> <li> <p>Ensure files created by <code>rye init</code>, such as <code>pyproject.toml</code> and initial python files end with a newline. #979</p> </li> <li> <p>Add <code>--refresh</code> argument on <code>-f</code>.  #994</p> </li> <li> <p>Preserve trailing newline in templates.  #979</p> </li> <li> <p>Update uv to 0.1.37.  #980</p> </li> <li> <p>Allow comments in <code>.python-version</code>.  #1038</p> </li> <li> <p>Update Python releases to include 3.12.3 et al.  #1022</p> </li> </ul>"},{"location":"changelog/#0320","title":"0.32.0","text":"<p>Released on 2024-03-29</p> <ul> <li> <p>Update uv to 0.1.26.  #924</p> </li> <li> <p>Always create <code>.gitignore</code> file in <code>rye init</code>.  #919</p> </li> <li> <p>Prevent <code>rye fetch --force</code> from removing a target directory that is not a Python installation.  #921</p> </li> <li> <p><code>rye list</code> always prints the currently installed packages even this project is not managed by Rye.  #940</p> </li> <li> <p>Fix error on using -v or -q with <code>rye fmt</code> or <code>rye lint</code>. #959</p> </li> <li> <p>Fix rye fetch detection of registered toolchain.  #931</p> </li> <li> <p>Ignore build-system configuration for virtual projects.  #929</p> </li> </ul>"},{"location":"changelog/#0310","title":"0.31.0","text":"<p>Released on 2024-03-22</p> <ul> <li> <p>Update uv to 0.1.23.  #916</p> </li> <li> <p>Allow <code>rye publish</code> working outside of project.  #910</p> </li> <li> <p><code>rye test --quiet</code> no longer implies <code>--no-capture</code>. #915</p> </li> <li> <p>Rye now can be used to fetch Python installations even when not using Rye   and build infos are no longer included by default.  This means that rather   than having interpreters at <code>~/.rye/py/cpython@3.11.1/install/bin/python3</code>   it will now reside at <code>~/.rye/py/cpython@3.11.1/bin/python3</code>.  #917</p> </li> <li> <p>Installer now recommends <code>uv</code> over <code>pip-tools</code>.  #918</p> </li> </ul>"},{"location":"changelog/#0300","title":"0.30.0","text":"<p>Released on 2024-03-19</p> <ul> <li> <p>Update uv to 0.1.21.  #884, #890, #904</p> </li> <li> <p>Fix incorrect flag passing of <code>rye test</code> <code>-q</code> and <code>-v</code>.  #880</p> </li> <li> <p>Rye now loads <code>.env</code> files.  This applies both for Rye's own   use of environment variables but also to scripts launched via   <code>run</code>.  #894</p> </li> <li> <p>Fix <code>rye add m --path ./m</code> causing a panic on windows.  #897</p> </li> </ul>"},{"location":"changelog/#0290","title":"0.29.0","text":"<p>Released on 2024-03-11</p> <ul> <li> <p>Updated to <code>uv</code> 0.1.17.  #850, #867</p> </li> <li> <p>Trap panics and silence bad pipe errors.  #862</p> </li> <li> <p>Updating <code>rye</code> will now also ensure that the self-venv is updated.  Previously   this was deferred until the next <code>sync</code>.  #863</p> </li> <li> <p>The <code>self update</code> command now accepts <code>--branch</code>.  #864</p> </li> <li> <p>Fixed an issue that caused pip-tools to not update.  #865</p> </li> <li> <p>Updates <code>build</code> and <code>certifi</code>.  #866</p> </li> </ul>"},{"location":"changelog/#0280","title":"0.28.0","text":"<p>Released on 2024-03-07</p> <ul> <li> <p><code>--skip-existing</code> is now available with Rye's <code>publish</code> command. #831</p> </li> <li> <p>Bumped <code>uv</code> to 0.1.15.  #760, #820, #837</p> </li> <li> <p>Bumped <code>ruff</code> to 0.3.0.  #821</p> </li> <li> <p>The <code>init</code> command now generates a script with the name of the   project rather than <code>hello</code>.  #801</p> </li> <li> <p>Retain markers when adding dependencies with features when uv is used.  #807</p> </li> <li> <p>Fixed a bug that caused repeated syncs not to recall all previous options.  #830</p> </li> <li> <p>Report <code>self-python</code> version in <code>--version</code>.  #843</p> </li> <li> <p>Fixes a bug where <code>rye config</code> would not create the <code>RYE_HOME</code> folder if needed.  #844</p> </li> <li> <p><code>rye add</code> now retains version and URL for the requirements when <code>uv</code> is used.  #846</p> </li> <li> <p>Added a <code>rye test</code> command which invokes <code>pytest</code>.  #847</p> </li> </ul>"},{"location":"changelog/#0270","title":"0.27.0","text":"<p>Released on 2024-02-26</p> <ul> <li> <p>rye now uses <code>uv</code> to bootstrap its internal packages and tools. #754</p> </li> <li> <p>rye no longer fails if an incorrect <code>VIRTUAL_ENV</code> environment   variable is exported.  #766</p> </li> <li> <p>Added latest Python builds.  #771</p> </li> <li> <p>When <code>uv</code> is used the prompt is now set to the project name.  #773</p> </li> <li> <p>Allow <code>rye fetch --force</code> to force re-fetch a downloaded toolchain.  #778</p> </li> <li> <p>Fixed a panic when adding a package to a virtual project.  #783</p> </li> <li> <p>Bumped <code>uv</code> to 0.1.11.  #790</p> </li> </ul>"},{"location":"changelog/#0260","title":"0.26.0","text":"<p>Released on 2024-02-23</p> <ul> <li> <p><code>init</code> now supports <code>--script</code> and <code>--lib</code> to generate a script or library project.  #738</p> </li> <li> <p>Fixed <code>rye config --show-path</code> abort with an error. #706</p> </li> <li> <p>Bumped <code>uv</code> to 0.1.9.  #719, #740, #746</p> </li> <li> <p>Bumped <code>ruff</code> to 0.2.2.  #700</p> </li> <li> <p>Prevent <code>rye toolchain remove</code> from removing the currently active toolchain.  #693</p> </li> <li> <p>Sync latest PyPy releases. #683</p> </li> <li> <p>Fixes an issue where when <code>uv</code> is enabled, <code>add</code> did not honor custom sources.  #720</p> </li> <li> <p>When <code>uv</code> is enabled, rye will now automatically sync on <code>add</code> and <code>remove</code>.  #677</p> </li> <li> <p>Rename <code>rye tools list</code> flags: <code>-i, --include-scripts</code> to <code>-s, --include-scripts</code> and <code>-v, --version-show</code> to <code>-v, --include-version</code>.  #722</p> </li> </ul>"},{"location":"changelog/#0250","title":"0.25.0","text":"<p>Released on 2024-02-19</p> <ul> <li> <p>Improved the error message if <code>config</code> is invoked without arguments.  #660</p> </li> <li> <p>Bump <code>uv</code> to 0.1.5.  #665, #675, #698</p> </li> <li> <p>When <code>uv</code> is enabled, <code>rye add</code> now uses <code>uv</code> instead of <code>unearth</code>   internally.  #667</p> </li> <li> <p>The installer now has slightly better wording for what the shims are doing.  #669</p> </li> <li> <p><code>uv</code> can now also be enabled on windows.  #675</p> </li> <li> <p>Removed the unsupported and un-used <code>arch</code> parameter from <code>fetch</code>.  #681</p> </li> <li> <p>Fixed the <code>-q</code> parameter not working for the <code>init</code> command.  #686</p> </li> <li> <p><code>rye tools list</code> shows broken tools if the toolchain was removed. #692</p> </li> <li> <p>Configure the ruff cache directory to be located within the workspace root. #689</p> </li> <li> <p>Use default toolchain to install tools.  #666</p> </li> <li> <p><code>rye --version</code> now shows if <code>uv</code> is enabled.  #699</p> </li> </ul>"},{"location":"changelog/#0240","title":"0.24.0","text":"<p>Released on 2024-02-15</p> <ul> <li> <p>Added new <code>rye list</code> command and deprecated <code>rye show --installed-deps</code> which it replaces.  #656</p> </li> <li> <p>Added experimental support for <code>uv</code>.  #657</p> </li> </ul>"},{"location":"changelog/#0230","title":"0.23.0","text":"<p>Released on 2024-02-13</p> <ul> <li> <p>When <code>behavior.venv-mark-sync-ignore</code> is set to <code>false</code> and the file system   does not support extended attributes, no longer will a warning be printed.  #633</p> </li> <li> <p>Fixed a bug that caused warnings about unsupported operations to be shown on Linux. #634</p> </li> <li> <p>The venv sync marker is now only updated when a new virtualenv is created.  #638</p> </li> <li> <p>Lockfiles now contain annotations.  #643</p> </li> </ul>"},{"location":"changelog/#0220","title":"0.22.0","text":"<p>Released on 2024-02-09</p> <ul> <li> <p>Virtual envs managed by Rye will now by default be marked to not sync to   known cloud storage systems (Dropbox and iCloud).  #589</p> </li> <li> <p>Fixed a bug where pip-tools sometimes did not get initialized.  #596</p> </li> <li> <p>Rye now prefers installed toolchains over newer latest toolchains unless   a precise pin is used.  #598</p> </li> <li> <p>Removed the non functional <code>shell</code> command.  #602</p> </li> <li> <p>Upgraded internal unearth dependency which resolved an issue where   <code>rye add tensorflow</code> would not work.  #614</p> </li> <li> <p>The installer now supports <code>RYE_TOOLCHAIN_VERSION</code>.  #606</p> </li> <li> <p><code>rye init</code> will no longer create packages with leading digits.  #616</p> </li> <li> <p>Rye now statically links <code>vcruntime</code> on Windows which no longer requires   the vs redist to be installed.  #622</p> </li> <li> <p><code>rye show</code> now prints out which sources are configured for a project.  #631</p> </li> </ul>"},{"location":"changelog/#0210","title":"0.21.0","text":"<p>Released on 2024-02-03</p> <ul> <li> <p><code>rye fetch</code> now is able to fetch impliciit version in all cases.  Previously   global shims were not properly defaulted which required the user to be explicit   with the fetch request.  #574</p> </li> <li> <p>The rye installer now prompts for the default toolchain version if global shims   are enabled.  #576</p> </li> <li> <p>The internal Python version was bumped to 3.12.  #576</p> </li> <li> <p>The installer now can automatically add Rye to <code>PATH</code> on most UNIX environments.  #580</p> </li> </ul>"},{"location":"changelog/#0200","title":"0.20.0","text":"<p>Released on 2024-02-01</p> <ul> <li> <p>Improved the error message when an update could not be performed because files   are in use.  #550</p> </li> <li> <p>Rye now supports virtual projects.  These are themselves not installed into the   virtualenv but their dependencies are.  #551</p> </li> <li> <p>Update the Python internals (python external dependencies) to new versions.  #553</p> </li> <li> <p>Update to newer versions of pip tools.  For Python 3.7 <code>6.14.0</code> is used, for   new Python versions <code>7.3.0</code> is used.  #554</p> </li> <li> <p>Added <code>rye fmt</code> and <code>rye lint</code> commands to format and lint with   the help of Ruff.  #555</p> </li> <li> <p>Restore cursor state on Ctrl-C.  This fixes some issues where in rare cases the   cursor would disappear even after shutting down rye.  #564</p> </li> <li> <p>Upon installation Rye now prompts if global shims should be enabled.  #566</p> </li> <li> <p>Add a warning about bugs to the <code>shell</code> command until the behavior has been   fixed.  #567</p> </li> </ul>"},{"location":"changelog/#0190","title":"0.19.0","text":"<p>Released on 2024-01-21</p> <ul> <li> <p>Improved the behavior of <code>rye fetch</code>.  When invoked without arguments it will now try to   fetch the version of the requested Python interpreter.  Specifically this combining   <code>pin</code> and <code>fetch</code> work in a much simplified manner.  #545</p> </li> <li> <p>Fixed an issue where <code>rye init</code> would pin a much too specific version in the <code>.python-version</code>   file that is generated.  #545</p> </li> <li> <p>On Windows the <code>PATH</code> is now automatically adjusted on install and uninstall.  This means that   manually adding the rye folder to the search path is no longer necessary.  #483</p> </li> <li> <p>Fixed a regression in 0.18 that caused the <code>add</code> command to fail.  #547</p> </li> </ul>"},{"location":"changelog/#0180","title":"0.18.0","text":"<p>Released on 2024-01-20</p> <ul> <li> <p>Incorporate new Python builds.  #535</p> </li> <li> <p>Disable revocation checks on windows to support corporate MITM proxies.  #537</p> </li> <li> <p>Detect when a virtualenv relocates and automatically re-create it on sync.  #538</p> </li> <li> <p>Added <code>lock --with-sources</code>, <code>sync --with-sources</code> and the new <code>rye.tool.lock-with-sources</code>   config.  Passing this will ensure that source references are included in the   lock files.  #540</p> </li> <li> <p>When using global python shims, the <code>.python-version</code> file is now correctly   picked up in all cases.  #541</p> </li> <li> <p>Added a helpful message if someone attempts to run the non existing <code>rye list</code>   command.  At a later point there should be a real listing command that can print   out the dependencies.  Today the only option is the <code>--installed-deps</code> option on   the <code>show</code> command which spits out dependencies in the format of the lockfile.  #543</p> </li> <li> <p>The installer will no longer attempt to symlink targets which are not valid   executables on the platform.  This works around some issues with Packages that   would prevent to install such as <code>changedetection.io</code>.  #542</p> </li> </ul>"},{"location":"changelog/#0170","title":"0.17.0","text":"<p>Released on 2024-01-15</p> <ul> <li> <p>Fixed default generated script reference.  #527</p> </li> <li> <p>Correctly fall back to home folder if HOME is unset.  #533</p> </li> </ul>"},{"location":"changelog/#0160","title":"0.16.0","text":"<p>Released on 2023-12-17</p> <ul> <li> <p>By default a script with the name of the project is now also configured.  #519</p> </li> <li> <p>Rye now configures hatchling better in <code>rye init</code> so that it works with   hatchling 1.19 and later.  #521</p> </li> <li> <p>Rye now detects the dummy Python shim that starts the windows store and   refuses to consider it.  #486</p> </li> </ul>"},{"location":"changelog/#0152","title":"0.15.2","text":"<p>Released on 2023-10-04</p> <ul> <li>Fixed the updater not replacing the python shim correctly on Linux.</li> </ul>"},{"location":"changelog/#0151","title":"0.15.1","text":"<p>Released on 2023-10-03</p> <ul> <li>Fixed the updater not replacing the python3 shim correctly.</li> </ul>"},{"location":"changelog/#0150","title":"0.15.0","text":"<p>Released on 2023-10-03</p> <ul> <li>Added support for Python 3.12.  #462</li> </ul>"},{"location":"changelog/#0140","title":"0.14.0","text":"<p>Released on 2023-10-01</p> <ul> <li> <p>Add support for fetching alternative CPU architectures.  #447</p> </li> <li> <p>The order of git submodule initialization was changed.  This improves the   automatic author detection when <code>includeIf</code> is used.  #443</p> </li> <li> <p>The linux shim installer code will no longer fall back to symlinks when a   hardlink cannot be created.  This is done as a symlinked shim will not   ever function correctly on Linux.  This prevents the shim executables like   <code>python</code> to instead act as if they are <code>rye</code>.  The fallback behavior is now   to copy the executable instead.  #441</p> </li> <li> <p>The installer now detects <code>fish</code> and will spit out additional instructions   for configuring the shell.</p> </li> <li> <p>Fix the wrong behavior when bump version.  #454</p> </li> </ul>"},{"location":"changelog/#0130","title":"0.13.0","text":"<p>Released on 2023-08-29</p> <ul> <li> <p>Add a <code>python3</code> shim on windows.  Previously entering <code>python3</code> in the   command line would always bring up the windows store python proxy even   when global shims were enabled.  As virtualenvs do not support the   <code>python3</code> executable on windows, the internal shim handling is now also   changed so that trying to launch <code>python3</code> will fall back to <code>python</code>.   This makes it possible to run <code>maturin build</code>.</p> </li> <li> <p>Add <code>maturin</code> build command to start a new maturin PyO3 project.</p> </li> </ul>"},{"location":"changelog/#0120","title":"0.12.0","text":"<p>Released on 2023-08-27</p> <ul> <li> <p>Improve handling of the pth files for TCL on pypy. #409</p> </li> <li> <p>The <code>rye tools list</code> command now accepts <code>-v</code> to also print out the   versions of the installed tools. #396</p> </li> <li> <p>Fixed parsing of versions by <code>rye version</code>. #397</p> </li> <li> <p>Improved the help message for <code>rye init</code>. #401</p> </li> <li> <p>The email address now defaults to a syntactically valid email address   if not known to prevent errors with some build tools.</p> </li> <li> <p>Added new Python versions.</p> </li> <li> <p>The rye installer now detects <code>NOEXEC</code> temporary folders and prints out   a more helpful error message. #394</p> </li> <li> <p>Fixed an issue where the author email was incorrectly detected. #382</p> </li> <li> <p>The prompt of new virtualenvs is now set to the project name. #383</p> </li> </ul>"},{"location":"changelog/#0110","title":"0.11.0","text":"<p>Released on 2023-07-18</p> <ul> <li> <p>Added new Python versions.</p> </li> <li> <p>Added a new config key <code>default.author</code> to configure the default author   that should be set.  This overrides the default author that is normally   loaded from the git config.  #377</p> </li> <li> <p>When importing with <code>rye init</code> and no <code>src</code> folder exists, it will not be   created.  #375</p> </li> <li> <p>Added support for <code>shell</code> command on Windows.  #363</p> </li> <li> <p>Pin down pip to an older version to avoid issues with an incompatible   <code>pip-tools</code> version.  This does not yet update pip-tools to 7.0 as there   are significant regressions in 7.x. #374</p> </li> <li> <p>The <code>version</code> command can show dynamic versions now. #355</p> </li> <li> <p><code>rye add</code> now properly checks some incompatible argument combinations.  #347</p> </li> <li> <p>There is now more toolchain validation.  This better supports cases where   rye was interrupted during sync.  #351</p> </li> </ul>"},{"location":"changelog/#0100","title":"0.10.0","text":"<p>Released on 2023-07-07</p> <ul> <li> <p>Fixed a bug with <code>rye init</code> not operating correctly due to a argument conflict.  #346</p> </li> <li> <p>Scripts now support a PDM style <code>call</code> script type.  #345</p> </li> <li> <p>The <code>init</code> command is now capable of importing existing projects.  #265</p> </li> <li> <p>Fixed the global shim behavior on Windows.  #344</p> </li> </ul>"},{"location":"changelog/#090","title":"0.9.0","text":"<p>Released on 2023-06-21</p> <ul> <li> <p>The internal Rye Python version is now 3.11.</p> </li> <li> <p>Rye now emits most messages, most of the time to stdout rather than stderr.  #342</p> </li> <li> <p><code>rye add</code> now accepts <code>--pin</code> to let one override the type of pin to use.  #341</p> </li> <li> <p>Added <code>rye config</code> to read and manipulate the <code>config.toml</code> file.  #339</p> </li> <li> <p>Added support for the new <code>behavior.global-python</code> flag which turns on global   Python shimming.  When enabled then the <code>python</code> shim works even outside of   Rye managed projects.  Additionally the shim (when run outside of Rye managed   projects) supports a special first parameter <code>+VERSION</code> which requests a   specific version of Python (eg: <code>python +3.8</code> to request Python 3.8).  #336</p> </li> <li> <p>Renamed the config key <code>default.dependency_operator</code> to <code>default.dependency-operator</code>   and <code>behavior.force_rye_managed</code> to <code>behavior.force-rye-managed</code>.  #338</p> </li> </ul>"},{"location":"changelog/#080","title":"0.8.0","text":"<p>Released on 2023-06-18</p> <ul> <li> <p>Rye for now prefers <code>&gt;=</code> over <code>~=</code> for newly added dependencies.</p> </li> <li> <p>The workspace member declaration is now platform independent.  If <code>members</code> is   now explicitly set to an empty list it will not fall back to auto discovery.  #331</p> </li> <li> <p><code>rye add</code> now pins versions with <code>==</code> instead of <code>~=</code> when the version of the   package does not use at least two components.  This means that for instance it   will now correctly use <code>openai-whisper==20230314</code> rather than   <code>openai-whisper~=20230314</code> which is not actually satisfiable.  #328</p> </li> <li> <p><code>rye install</code> now lets you install dependencies into the tool's virtualenv   during installation that are undeclared via the new <code>--extra-requirement</code>   option.  #326</p> </li> <li> <p>Improved handling of relative path installations by setting <code>PROJECT_ROOT</code>   the same way as PDM does.  #321</p> </li> <li> <p>Workspaces will now never discover <code>pyproject.toml</code> files in any dot   directories. (Name starting with <code>.</code>)  #329</p> </li> <li> <p>Fixed <code>rye build</code> not working correctly on Windows.  #327</p> </li> </ul>"},{"location":"changelog/#070","title":"0.7.0","text":"<p>Released on 2023-06-12</p> <ul> <li> <p><code>rye sync</code> and <code>rye lock</code> now accept <code>--pyproject</code>.  #296</p> </li> <li> <p>Added JSON output to <code>rye toolchain list</code> by adding <code>--format=json</code>.  #306</p> </li> <li> <p><code>rye version</code> can bump version by <code>--bump</code> option now.  #298</p> </li> <li> <p>Fixed members not handled correctly in workspaces.  #300</p> </li> <li> <p>Add <code>--clean</code> for <code>build</code> command.  #297</p> </li> <li> <p>Fixed an issue where pip was not invoked from the right working directory   causing issues for workspace installations.  #292</p> </li> <li> <p><code>rye init</code> now accepts <code>--private</code> to set the <code>Private :: Do Not Upload</code> classifier   that prevents uploads to PyPI.  #291</p> </li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":"<p>Released on 2023-06-03</p> <ul> <li> <p>Add <code>version</code> subcommand for rye. #285</p> </li> <li> <p>Fixed <code>rye pin</code> pinning the wrong version.  #288</p> </li> <li> <p>Calling <code>rye init</code> on the root directory no longer fails.  #274</p> </li> <li> <p><code>rye run</code>, <code>show</code>, <code>pin</code>, <code>shell</code> and <code>build</code> now take a <code>--pyproject</code>   argument. #232</p> </li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<p>Released on 2023-05-31</p> <ul> <li> <p>Rye will no longer enforce a downloaded interpreter for the internal   toolchain.  If one has been registered that is compatible it will be   used.  Additionally the installer now supports the <code>RYE_TOOLCHAIN</code>   environment variable which allows a user to supply an already existing   Python interpreter at install time.  #267</p> </li> <li> <p>The <code>publish</code> command now supports <code>--yes</code> to disable prompts.  #270</p> </li> <li> <p>When a Python debug build (<code>Py_DEBUG</code>) is registered as custom toolchain,   <code>-dbg</code> is automatically appended to the name by default.  #269</p> </li> <li> <p>lto+pgo builds are now preferred for the Python toolchain builds when   available.  #268</p> </li> <li> <p>It's now possible for <code>.python-version</code> to request partial Python versions   in which case the latest available is used.  In particular this means that   a version like <code>3.10</code> can be written into <code>.python-version</code> rather than   <code>3.10.11</code>.  This can be accomplished by invoking <code>pin</code> with the new   <code>--relaxed</code> flag.  #255</p> </li> <li> <p>Workspaces will no longer discover <code>pyproject.toml</code> files in virtualenvs   or <code>.git</code> folders.  #266</p> </li> <li> <p>Adding or removing dependencies with <code>add</code> or <code>remove</code> now reformats   the <code>dependencies</code> array in the <code>pyproject.toml</code> file to multi-line   with trailing commas.  This should result in significantly better   diffing behavior out of the box.  #263</p> </li> <li> <p>Default build-system and license can be specified in global config.  #244</p> </li> <li> <p>Fixed an issue where the <code>init</code> command would not let you create   <code>flit</code> based projects.  #254</p> </li> <li> <p>Resolve an error (\"No such file or directory\") shown after updates on   Linux machines.  #252</p> </li> <li> <p>The built-in updater now validates checksums of updates when updates have   SHA-256 hashes available.  #253</p> </li> <li> <p><code>init</code> now accepts <code>--no-pin</code> to not create a <code>.python-version</code> file.  #247</p> </li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>Released on 2023-05-29</p> <ul> <li> <p>Releases starting with <code>0.4.0</code> onwards are published with SHA256 checksum   files for all release assets.  These files are not yet validated by the   installer or updater however.</p> </li> <li> <p>The <code>install</code> command can now install tools from custom indexes.  #240</p> </li> <li> <p>Virtualenvs on Unix are now created with a hack to pre-configure TCL and   TKinter.  #233</p> </li> <li> <p>Fix invalid version error when using rye init with custom toolchain.  #234</p> </li> <li> <p>Failed tool installations now properly clean up.  #225</p> </li> <li> <p>Correctly swap the rye executable on windows when performing an update   to a git version via <code>self update</code>.</p> </li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>Released on 2023-05-27</p> <ul> <li> <p>Support retrieving username and repository-url from credentials if not   provided for the <code>publish</code> command.  #217</p> </li> <li> <p>The installer now validates the availability of shared libraries   on Linux with <code>ldd</code> and emits an error with additional information   if necessary shared libraries are missing.  #220</p> </li> <li> <p>It's now possible to configure http and https proxies.  #215</p> </li> <li> <p>If a package is not found because it only has matching pre-releases,   a warning is now printed to tell the user to pass <code>--pre</code>.  #218</p> </li> <li> <p>Add <code>--username</code> parameter for rye publish.  #211</p> </li> <li> <p>The shims are now more resilient.  Previously a <code>pyproject.toml</code> file   caused in all cases a virtualenv to be created.  Now this will only   happen when the <code>rye.tool.managed</code> flag is set to <code>true</code>.  The old   behavior can be forced via the global config.  #212</p> </li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>Released on 2023-05-23</p> <ul> <li> <p>Resolved a bug where on Windows hitting the shift key (or some other keys)   in confirm prompts would cause an error.</p> </li> <li> <p>The installer on Windows now warns if symlinks are not enabled and directs   the user to enable developer mode.  The <code>--version</code> output now also   shows if symlinks are available.  #205</p> </li> <li> <p>Support auto fix requires-python when there is a conflict. #160</p> </li> <li> <p>Added support for custom indexes.  #199</p> </li> <li> <p><code>rye add</code> no longer complains when a local version information is   in the version.  #199</p> </li> </ul>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>Released on 2023-05-22</p> <ul> <li> <p>Fixed dev-dependencies not being installed when using workspace.  #170</p> </li> <li> <p><code>init</code> no longer creates invalid flit config.  #195</p> </li> <li> <p>Support direct references when adding a package.  #158</p> </li> <li> <p>Fixed a bug with uninstall on Unix platforms.  #197</p> </li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>Released on 2023-05-18</p> <ul> <li> <p>The installer on windows will now ask for a key to be pressed so it does   not close the window without information.  #183</p> </li> <li> <p>Fixed an issue on macOS where the installer would die with \"os error 24\"   when directly piped to bash.  #184</p> </li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>Released on 2023-05-17</p> <ul> <li> <p>Rye now comes with binary releases for some platforms.</p> </li> <li> <p>A new <code>self uninstall</code> command was added to uninstall rye and the new   <code>self update</code> command updates to the latest release version.</p> </li> <li> <p>Rye now includes a <code>publish</code> command for publishing Python packages to a   package repository.  #86</p> </li> <li> <p>Script declarations in <code>pyproject.toml</code> now permit chaining and custom   environment variables.  #153</p> </li> <li> <p>Added <code>tools install</code> and <code>tools uninstall</code> as aliases for <code>install</code> and   <code>uninstall</code> and added <code>tools list</code> to show all installed tools.</p> </li> <li> <p>Rye is now capable of downloading a selected set of PyPy releases.  To do   so use <code>rye pin pypy@3.9.16</code> or any other supported PyPy release.</p> </li> <li> <p>Custom cpython toolchains are now registered just as <code>cpython</code> rather   than <code>custom-cpython</code>.</p> </li> <li> <p>Rye now supports Python down to 3.7.</p> </li> <li> <p>Rye's <code>self</code> command now includes a <code>completion</code> subcommand to generate   a completion script for your shell.</p> </li> <li> <p>The downloaded Python distributions are now validated against the   SHA-256 hashes.</p> </li> <li> <p>Rye now builds on windows.  This is even more experimental though   than support for Linux and macOS.</p> </li> <li> <p>Added <code>--features</code> and <code>--all-features</code> for <code>lock</code> and <code>sync</code>.</p> </li> <li> <p>Rye will now look at the <code>RYE_HOME</code> to determine the location of the   <code>.rye</code> folder.  If it's not set, <code>$HOME/.rye</code> is used as before.</p> </li> <li> <p>Rye now has a most consistent handling for virtualenv versions.  If   <code>.python-version</code> is provided, that version is used.  Otherwise if   <code>requires-python</code> is set in the <code>pyproject.toml</code>, that version is used   instead.  When a new project is created the <code>.python-version</code> file is   written and the current latest cpython version is picked.</p> </li> <li> <p>It's now possible to explicitly set the <code>name</code> of the project when   initializing a new one.</p> </li> <li> <p>Rye's <code>init</code> command now attempts to initialize projects with <code>git</code> and   will automatically create a <code>src/project_name/__init__.py</code> file.</p> </li> <li> <p>Rye can now also generate a license text when initializing projects.</p> </li> <li> <p>Rye now supports negative (exclusion) dependencies.  These can be used to   prevent a dependency from installing, even if something else in the graph   depends on it.  Use <code>rye add --exclude package-name</code> to add such a dependency.</p> </li> <li> <p><code>sync</code> now accepts <code>--no-lock</code> to prevent updating the lock file.</p> </li> <li> <p>Rye's <code>add</code> command now accepts a <code>--pre</code> parameter to include pre-release.</p> </li> <li> <p>Rye's <code>pin</code> command now updates the pyproject.toml requires-python.</p> </li> <li> <p>Rye's <code>install</code> command now accepts a <code>--include-dep</code> parameter to include   scripts from one or more given dependencies.</p> </li> <li> <p>Rye now honors <code>requires-python</code> in the <code>add</code> command.  This means the the   initial resolution will not pick a version higher than what's supported by   the lower boundary.</p> </li> <li> <p>When installing packages as global tools, a warning is now emitted if there   were no scripts in the package.  Additionally installing packages from local   paths and zip files is now supported.</p> </li> <li> <p>A <code>rye self update</code> command was added to compile and install the latest   version via cargo.</p> </li> <li> <p>Added more convenient ways to install from git/urls by supplying a <code>--git</code>   or <code>--url</code> parameter.  This will behind the scenes format a PEP 508 requirement   string.</p> </li> <li> <p>Added a <code>shell</code> command which will spawn a shell with the virtualenv activated.</p> </li> <li> <p>Added a <code>make-req</code> command to conveniently format out PEP 508 requirement   strings from parts.</p> </li> <li> <p>The internal virtualenv used to manage <code>pip-tools</code> and other libraries now   automatically updates when necessary.</p> </li> <li> <p><code>rye toolchain register</code> can now be used to register a local python installation   as toolchain with rye.</p> </li> <li> <p><code>rye build</code> was added to allow building <code>sdist</code> and <code>bdist_wheel</code> distributions.</p> </li> <li> <p>Rye now correctly handles whitespace in folder names.</p> </li> </ul>"},{"location":"community/","title":"Community","text":"<p>Rye is a new project and feedback is greatly appreciated.  Lots of it.  Because of this there are various different ways in which you can engage with either the developer or other members of the community:</p> <ul> <li>Discussion Forum, to discuss the project   on GitHub</li> <li>Discord, for conversations with other developers in text form</li> <li>Issue Tracker, if you run into bugs or have suggestions</li> </ul> <p>You can also reach out via Twitter or Bluesky.</p>"},{"location":"community/#badges","title":"Badges","text":"<p>Want to show that you are using Rye?  Why not throw a badge into your project's <code>README.md</code>:</p> <pre><code>[![Rye](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/rye/main/artwork/badge.json)](https://rye.astral.sh)\n</code></pre> <p>... or <code>README.rst</code>:</p> <pre><code>.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/rye/main/artwork/badge.json\n    :target: https://rye.astral.sh\n    :alt: Rye\n</code></pre> <p>... or, as HTML:</p> <pre><code>&lt;a href=\"https://rye.astral.sh\"&gt;&lt;img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/rye/main/artwork/badge.json\" alt=\"Rye\" style=\"max-width:100%;\"&gt;&lt;/a&gt;\n</code></pre> <p></p>"},{"location":"philosophy/","title":"Philosophy and Vision","text":"<p>Rye was built to solve my problems.  Here is what was on my mind when I built it:</p> <ul> <li> <p>Virtualenvs: while I personally do not like virtualenvs that much, they are   so widespread and have reasonable tooling support, so I chose this over   <code>__pypackages__</code>.</p> </li> <li> <p>No Default Dependencies: the virtualenvs when they come up are completely void   of dependencies. Not even <code>pip</code> or <code>setuptools</code> are installed into it. Rye   manages the virtualenv from outside the virtualenv.</p> </li> <li> <p>No Core Non-Standard Stuff: Rye (with the exception of its own <code>tool</code> section   in the <code>pyproject.toml</code>) uses standardized keys. That means it uses regular   requirements as you would expect. It also does not use a custom lock file   format and uses <code>uv</code>.</p> </li> <li> <p>No Pip: Rye uses <code>uv</code> to manage dependencies,   through <code>pyproject.toml</code> only.</p> </li> <li> <p>No System Python: I can't deal with any more linux distribution weird Python   installations or whatever mess there is on macOS. I used to build my own Pythons   that are the same everywhere, now I use indygreg's Python builds.   Rye will automatically download and manage Python builds from there. No compiling,   no divergence.</p> </li> <li> <p>Project Local Shims: Rye maintains a <code>python</code> shim that auto discovers the   current <code>pyproject.toml</code> and automatically operates below it. Just add the   shims to your shell and you can run <code>python</code> and it will automatically always   operate in the right project.</p> </li> </ul>"},{"location":"philosophy/#what-could-be","title":"What Could Be?","text":"<p>There are a few shortcomings in the Python packaging world, largely as a result of lack of standardization. Here is what this project ran into over the years:</p> <ul> <li> <p>No Python Binary Distributions: CPython builds from python.org are completely   inadequate. On some platforms you only get an .msi installer, on some you   literally only get tarballs. The various Python distributions that became popular   over the years are diverging greatly and cause all kinds of nonsense downstream.   This is why this Project uses the indygreg standalone builds. I hope that with   time someone will start distributing well maintained and reliable Python builds   to replace the mess we are dealing with today.</p> </li> <li> <p>No Dev Dependencies: Rye currently needs a custom section in the <code>pyproject.toml</code>   to represent dev dependencies. There is no standard in the ecosystem for this. It   really should be added.</p> </li> <li> <p>No Local Dependency Overlays: There is no standard for how to represent local   dependencies. Rust for this purpose has something like <code>{ path = \"../foo\" }</code>   which allows both remote and local references to co-exist and it rewrites them   on publish.</p> </li> <li> <p>No Exposed Pip: pip is intentionally not exposed. If you install something   into the virtualenv with pip, it disappears next time you sync.</p> </li> <li> <p>No Workspace Spec: for monorepos and things of that nature, the Python ecosystem   would need a definition of workspaces. Today that does not exist which forces every   tool to come up with it's own solutions to this problem.</p> </li> <li> <p>No Basic Script Section: There should be a standard in <code>pyproject.toml</code> to   represent scripts like <code>rye</code> does in <code>rye.tools.scripts</code>.</p> </li> </ul>"},{"location":"philosophy/#the-vision","title":"The Vision","text":"<p>This describes of what I envision Python packaging and project management could look like in an ideal world:</p>"},{"location":"philosophy/#the-rust-experience","title":"The Rust Experience","text":"<p>Coming from a Rust environment there are two tools which work together: <code>rustup</code> and <code>cargo</code>.  The first one of those is used to ensure that you have the correct Rust toolchain on your machine.  Rust greatly prefers binary distributions of the language from the official website over external distributions.</p> <p><code>cargo</code> is the main entry point to development in Rust.  It acts as the tool to trigger test runs, start the build process, shell out to the documentation building tool, linters but also things such as workspace management, dependency management and package publishing.</p> <p>Crucially a very important aspect of the Rust development experience is the strong commitment to semver and the built-in support for it.  This goes very deep.  The resolver for instance will deduplicate matching dependencies throughout the graph. This means that if four libraries depend on <code>libc@0.2</code>, they will all resolve to that dependency.  However if another need arises for <code>libc@1.0</code>, then it's possible for the dependency graph to result in both being loaded!</p> <p>The ecosystem greatly depends on this.  For instance when a new major release is made of a very core library, in some cases extra care is taken to unify the now incompatible versions by re-exporting core types from the newer to the older version.  Thus it's for instance possible for <code>important-lib@0.2.32</code> to depend on <code>important-lib@1.0</code> internally so it can make the transition easier.</p> <p>Additionally Rust heavily leverages lockfiles.  Whenever you compile, the dependencies are locked in place and future builds reuse the same dependency versions unless you update.</p> <p>Most importantly though the Rust ecosystem has embraced <code>rustup</code> and <code>cargo</code> that the vast majority of people are using these tools on a daily basis.  Even developers who pick other tools like buck, are still using <code>cargo</code> regularly.</p>"},{"location":"philosophy/#going-python","title":"Going Python","text":"<p>Rye wants to explore if such an experience is possible with Python.  I believe it can! There is quite a lot of the ecosystem that can be leveraged for this purpose but there is even more that would need to be built.</p> <p>Important note: when you read \"rye\" in the context of the document it talks about what a potential tool like rye could be.  It might as well be that one of the many tools that exist today, turn into that very tool that is described here.</p> <p>My sentiment is that unless \"the one tool\" can emerge in the Python world, the introduction of yet another tool might be a net-negative to the ecosystem.  Plenty of tools have been created over the years, and unfortunately it hasn't been able to rally the majority of the Python community behind any tool.  I do however believe it is possible.</p>"},{"location":"philosophy/#bootstrapping-python","title":"Bootstrapping Python","text":"<p>I believe the right approach is that &gt;95% of users get a Python distribution via <code>rye</code> and not to have <code>rye</code> pick up a system installed Python distribution.  There are good reasons for using a system Python installation, but it should be the exception not the rule.  Most importantly because a Python distribution that <code>rye</code> puts in place can be made to have reliable and simple rules that do not differ between systems.</p> <p>A huge cause of confusion and user frustration currently comes from Linux distribution specific patches on top of Python that break tools and change behavior, particularly in the python packaging ecosystem.</p> <p>Bootstrapping Python via an independent tool has other benefits as well.  It for instance allows much easier cross-python version testing via tox or CI.</p> <p>What needs to be done:</p> <ul> <li>Provide widely available Python builds, with largely standardized structure   retrievable from the internet. PEP 711 is a step   in that direction.</li> </ul>"},{"location":"philosophy/#a-stronger-resolver","title":"A Stronger Resolver","text":"<p>Today there are a ton of different resolvers in the Python ecosystem.  Pip has two, poetry has one, pdm has one, different independent Python and Rust resolvers exist on top of that. Resolvers are important, but unfortunately, there are both too many and too many issues with the existing ones.  Here is what I believe a resolver needs to be able to accomplish:</p> <ul> <li> <p>Allow resolving across markers: most resolvers in the Python ecosystem today can only   resolve for the current interpreter and platform (eg: pip, pip-tools).  This means it cannot   create a resolution that is equally valid for a different platform.  In part this is   a problem because of how environment markers in Python are defined.  They allow a level of   expressiveness that cannot be reflected by most tools, however a subset could be supported.</p> </li> <li> <p>Multi-version resolution support: this is a bit foreshadowing, but I believe for a   variety of reasons it needs to be possible for a resolver to not unify all requirements   to a single version, but to support multiple independent resolutions across major versions   of libraries.  A future resolver should be able to permit <code>package==2.0</code> and <code>package==1.1</code>   to both be resolved for different parts of the tree.</p> </li> <li> <p>Resolver API: access to the resolver is important.  For editor plugins, or custom   tools it's always necessary to be able to resolve packages.  For instance if you want   something as trivial as \"add latest supported version of 'flask' to my <code>pyproject.toml</code>\"   you need to be able to work with the resolver.</p> </li> <li> <p>Filters: I strongly believe that a good resolver also needs a filter on top.  For   instance it must be possible for a developer to restrict the resolver to stay within the   bounds of the target Python version and to never upgrade into a tree containing Python   versions that are too new.  Likewise for supply chain safety a resolver should be able to   restrict itself to a set of vetted dependencies.</p> </li> </ul> <p>What needs to be done:</p> <ul> <li>Create a reusable resolver that can be used by multiple tools in the ecosystem.</li> <li>Make the resolver work with the proposed metadata cache</li> <li>Expose the resolver as API for multiple tools to use.</li> <li>Add a policy layer into the resolver that can be used to filter down the dependencies   before use.</li> </ul>"},{"location":"philosophy/#metadata-caches","title":"Metadata Caches","text":"<p>Because of the rather simplistic nature of Python packages and package indexes a resolver will always be restricted by the metadata that it can reliably pull.  This is particularly bad if the system needs to fall back to <code>sdist</code> uploads which in the worst case requires executing python code to determine the dependencies, and those dependencies might not even match on different platforms.</p> <p>However this is a solvable problem with sufficient caching, and with the right design for the cache, this cache could be shared.  It might even be quite interesting for PyPI to serve up \"fake\" metadata records for popular sdist only packages to help resolvers. This might go a long way in improving the quality of the developer experience.</p> <p>What needs to be done:</p> <ul> <li>Local metadata caches are added for the resolver to use</li> <li>PyPI gains the ability to serve dependency meta data</li> </ul>"},{"location":"philosophy/#lockfiles","title":"Lockfiles","text":"<p>It's unclear if a standard can emerge for lock files given the different requirements, but a Python packaging solution needs to have support for these.  There are a lot of different approaches to lockfiles today (poetry and pdm for instance have them) but it's not entirely clear to me that the way they are handled today is sufficiently pragmatic to enable a tool that is based on lockfiles to get majority adoption.</p> <p>The reason in part relates the suboptimal situation with resolvers (eg: large projects can take ten minutes or longer to dependency check in poetry), on the other hand however also because of the reality of how dependencies are currently declared.  For instance certain libraries will \"over\" depend on third party libraries, even if they are not needed for a developer.  These pulled in dependencies however will still influence the resolver.</p> <p>Most importantly a good lockfile also covers platforms other than the current developer's machine.  This means that if a project supports Windows and Linux, the lockfile should be handling either dependency trees.  This is what cargo accomplishes today, but cargo has a a much simpler problem to solve here because it has perfect access to package metadata which resolvers in Python do not have today.  What is also problematic in Python is that certain parts of the dependency tree can be version dependent.  In Rust a library A either depends on library B or it does not, but it does not depend on it conditional to a Python version.</p> <p>The total expressiveness of Python dependencies is challenging.  The lack of good metadata access for the resolver combined with the ability to make dependencies optional conditional to the Python version is tricky by itself.  The complexity however is compounded by the fact that the resolver needs to come to a solution that can only result in a single resolved version per package.</p> <p>What needs to be done:</p> <ul> <li>Experiment with a restricted lock format that satisfies a subset of what markers provide   today, that strikes a good balance.</li> <li>Provide lockfile support as part of the resolver library.</li> </ul>"},{"location":"philosophy/#upper-bounds-multi-versioning","title":"Upper Bounds &amp; Multi Versioning","text":"<p>Resolving Python dependencies is particularly challenging because a single solution must be found per package.  A reason this works at all in the Python ecosystem is that most libraries do not set upper bounds.  This means that they will be eagerly accepting future libraries even at the cost of not supporting them.  That's largely possible because Python is a dynamic language and a lot of flexibility is usually possible here.  However with increased utilization of type information in the Python world, and maybe with stronger desires for proper locking, it might be quite likely that upper version bounds become more common.</p> <p>Once that happens however, the Python ecosystem will quite quickly run into blocking future upgrades until the entire dependency graph has moved up which creates a lot of friction. Other ecosystems have solved this problem by strictly enforcing semver semantics onto packages and by permitting multiple semver incompatible libraries to be loaded simultaneously.  While usually a library is only allowed to permit on a single version of a dependency, that dependency can exist in different versions throughout the dependency tree.</p> <p>In Python there is a perceived worry that this cannot be accomplished because of how site-packages, <code>PYTHONPATH</code> and <code>sys.modules</code> works.  However I believe these to be solvable issues.  On the one hand because <code>.pth</code> files can be used to completely change how the import system works, secondly because the <code>importlib.metadata</code> API is strong enough these days to allow a package to resolve it's own metadata.  The combination of the two can be used to \"redirect\" imports in <code>sys.modules</code> and import statements to ensure that if a library imports a dependency of itself, it ends up with the right version.</p> <p>What needs to be done:</p> <ul> <li>Add a new metadata key to <code>pyproject.toml</code> that declares that a package supports multi-versioning</li> <li>Enforce semver semantics on multi-version dependencies</li> <li>Provide an import hook that provides multi-version imports as part of Rye</li> <li>Relax the resolver to permit multiple solutions for multi-version dependencies</li> </ul>"},{"location":"philosophy/#workspaces-and-local-multi-path-references","title":"Workspaces and Local / Multi Path References","text":"<p>With growing development teams one of the most frustrating experiences is the inability to break up a monolithic Python module into smaller modules without having to constantly publish minor versions to a package index.  The way the Rust ecosystem deals with this issue is two-fold: on the one hand Rust supports workspaces natively.  Workspaces share dependencies and the resolver results.  The equivalent in Python would be that a workspace shares a virtualenv across all of the projects within in.  The second way in which Rust solves this problem is to permit a dependency to both support declaration of the package name, index but also local reference.</p> <p>While also Rust does not permit a crate to be published to a package index with references to packages outside of the index, a separate rewrite step kicks in ahead of publish to clean out invalid dependency references.  If no valid reference remains, the package will not publish.</p> <p>What needs to be done:</p> <ul> <li>requirement declarations need to be expanded to support defining the name of the index where   they can be found, and optional local path references.</li> </ul>"},{"location":"philosophy/#every-project-in-a-virtualenv","title":"Every Project in a Virtualenv","text":"<p>While virtualenv is not my favorite tool, it's the closest we have to a standard.  I proposed that there is always one path for a virtualenv <code>.venv</code> and when Rye manages it, users should not interact with it manually.  It's at that point rye's responsibility to manage it, and it shall manage it as if it was a throw-away, always re-creatable scratch-pad for dependencies.</p> <p>Preferably over time the structure of virtualenvs aligns between different Python versions (eg: Windows vs Linux) and the deeply nested <code>lib/py-ver/site-packages</code> structure is flattened out.</p> <p>What needs to be done:</p> <ul> <li>Agree on a name for where managed virtualenvs are placed (eg: <code>.venv</code> in the workspace root)</li> </ul>"},{"location":"philosophy/#dev-and-tool-dependencies","title":"Dev and Tool Dependencies","text":"<p>Another topic that is currently unresolved across tools in the ecosystem is how to work with dependencies that are not used in production.  For instance it's quite common that a certain dependency really only matters on the developer's machine.  Today pdm and some other tools have custom sections in the <code>pyproject.toml</code> file to mark development dependencies, but there is no agreement across tools on it.</p> <p>What needs to be done:</p> <p>There needs to be an agreed upon standard for all tools.  See this discussion</p>"},{"location":"philosophy/#opinionated-defaults","title":"Opinionated Defaults","text":"<p>Python against PEP-8's wishes just has too many ways in which things can be laid out.  There should be a much stronger push towards encouraging common standards:</p> <p>What needs to be done:</p> <ul> <li>Rye shall ship with the one true formatter</li> <li>Rye shall ship with the one true linter</li> <li>Rye shall always create a preferred folder structure for new projects</li> <li>Rye shall loudly warn if <code>package-foo</code> does not provide a <code>package_foo</code> module</li> </ul>"},{"location":"philosophy/#existing-tools","title":"Existing Tools","text":"<p>Some of the existing tools in the ecosystem are close, and there is a good chance that some of these might be able to combine forces to create that one-true tool.  I hope that there is enough shared interest, that we don't end up with three tools that all try to be Rye.</p>"},{"location":"guide/","title":"Introduction","text":"<p>Rye is still a very experimental tool, but this guide is here to help you get started.  Before we dive into the installation and basic usage guide it's important for you to understand what Rye actually is.</p> <p>Rye is a one-stop-shop tool.  The idea is that as a Python developer all you need to know is Rye, because Rye is your start into the experience.  As a Rye user you do not even need to install Python yourself as Rye does this for you. This means to use Rye, you just need to install Rye, the rest is done by Rye itself.</p> <p>Once Rye is on your system, it can automatically install Python interpreters for you, install packages from package indexes, manage virtualenvs behind the scenes and more.</p> <p>Interested?  Then head over to Installation to learn about how to get Rye onto your system.  Once that is done, read the Basics to learn about how Rye can be used.</p>"},{"location":"guide/basics/","title":"Basics","text":"<p>To use Rye you need to have a <code>pyproject.toml</code> based Python project.  For this guide you can create one with <code>rye init</code> which will create a new folder with a new project inside:</p> <pre><code>rye init my-project\ncd my-project\n</code></pre> <p>The following structure will be created:</p> <pre><code>.\n\u251c\u2500\u2500 .git\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .python-version\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 my_project\n        \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Good to Know</p> <p>The <code>init</code> command accepts a lot of options to customize what it generates.  Run <code>rye init --help</code> to see all the options available in the version you have installed.</p> <p>A <code>pyproject.toml</code> is used to store metadata about your project as well as some Rye configuration.  Most of Rye's commands will require a <code>pyproject.toml</code> to work.  Note that Rye today does not support <code>setup.py</code> based projects.  Note that when Rye initializes a project it also writes a <code>.python-version</code> file.  This file contains the version number of the Python version that should be used for this project.  It can be changed by running <code>rye pin</code>.  For instance to tell Rye to use Python 3.10:</p> <pre><code>$ rye pin 3.10\n</code></pre>"},{"location":"guide/basics/#first-sync","title":"First Sync","text":"<p>Once that is done, you can use <code>rye sync</code> to get the first synchronization.  After that, Rye will have created a virtualenv in <code>.venv</code> and written lockfiles into <code>requirements.lock</code> and <code>requirements-dev.lock</code>.</p> <pre><code>rye sync\n</code></pre> <p>The virtualenv that Rye manages is placed in <code>.venv</code> next to your <code>pyproject.toml</code>. The first time you run this you will notice that Rye automatically downloaded and installed a compatible CPython interpreter for you.  If you have already another Python installation on your system it will not be used!  For more information about this behavior read about toolchains.</p> <p>You can activate and work with it as normal with one notable exception: the Python installation in it does not contain <code>pip</code>.  If you have correctly installed Rye with the shims enabled, after the sync you can run <code>python</code> and you will automatically be operating in that virtualenv, even if it's not enabled.  You can validate this by printing out <code>sys.prefix</code>:</p> <pre><code>python -c \"import sys; print(sys.prefix)\"\n</code></pre> <p>It will print out the full path to the managed virtualenv.</p>"},{"location":"guide/basics/#adding-dependencies","title":"Adding Dependencies","text":"<p>Use the <code>add</code> command to add dependencies to your project.</p> <pre><code>rye add \"flask&gt;=2.0\"\n</code></pre> <p>Followed by <code>rye sync</code> to install the dependency into the virtual environment.  If you want to add packages from custom indexes, you have to configure the source first.</p>"},{"location":"guide/basics/#listing-dependencies","title":"Listing Dependencies","text":"<p>You can invoke <code>rye list</code> to get a dump of all installed dependencies of your project. Note that this only lists dependencies that are actually installed, so make sure to <code>sync</code> first.</p> <pre><code>rye list\n</code></pre>"},{"location":"guide/basics/#remove-a-dependency","title":"Remove a Dependency","text":"<p>Use the <code>remove</code> command to remove a dependency from the project again.</p> <pre><code>rye remove flask\n</code></pre>"},{"location":"guide/basics/#working-with-the-project","title":"Working with the Project","text":"<p>To run executables in the context of the virtualenv you can use the <code>run</code> command. For instance, to use <code>black</code>, add it to the project, sync the virtual environment, and run it over the current directory like this:</p> <pre><code>rye add black\nrye sync\nrye run black .\n</code></pre> <p>If you want to have the commands available directly you will need to activate the virtualenv like you do normally.  To activate the virtualenv, use the standard methods:</p> UnixWindows <pre><code>. .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>To deactivate it again run <code>deactivate</code>:</p> <pre><code>deactivate\n</code></pre>"},{"location":"guide/basics/#inspecting-the-project","title":"Inspecting the Project","text":"<p>The <code>rye show</code> command can print out information about the project's state.  By just running <code>rye show</code> you can see which Python version is used, where the virtualenv is located and more.</p> <pre><code>rye show\n</code></pre>"},{"location":"guide/basics/#executable-projects","title":"Executable projects","text":"<p>To generate a project that is aimed to provide an executable script, use <code>rye init --script</code>:</p> <pre><code>rye init --script my-project\ncd my-project\n</code></pre> <p>The following structure will be created:</p> <pre><code>.\n\u251c\u2500\u2500 .git\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .python-version\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 my_project\n        \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 __main__.py\n</code></pre> <p>The <code>pyproject.toml</code> will be generated with a <code>[project.scripts]</code> section containing a <code>my-project</code> script that points to the <code>main()</code> function of <code>__init__.py</code>. After you synchronized your changes, you can run the script with <code>rye run my-project</code>.</p> <pre><code>rye sync\nrye run my-project\n</code></pre>"},{"location":"guide/config/","title":"Configuration","text":"<p>Most of Rye's configuration is contained within the <code>pyproject.toml</code> file.  There is however also a bit of global configuration to influence how it works.</p>"},{"location":"guide/config/#changing-home-folder","title":"Changing Home Folder","text":"<p>By default Rye places all its configuration in <code>~/.rye</code> on Unix and <code>%USERPROFILE%\\.rye</code> on Windows.  This behavior can be changed via the <code>RYE_HOME</code> environment variable.  This is useful if you do not like the default location where Rye places its configuration or if you need to isolate it.</p>"},{"location":"guide/config/#home-folder-structure","title":"Home Folder Structure","text":"<p>The <code>.rye</code> home folder contains both user configuration as well as Rye-managed state such as installed toolchains.  The following files and folders are placed within the <code>.rye</code> folder.  Note that not all are always there.</p>"},{"location":"guide/config/#configtoml","title":"<code>config.toml</code>","text":"<p>This is a configuration file that influences how Rye operates.  Today very little configuration is available there.  For the available config keys see Config File.</p>"},{"location":"guide/config/#self","title":"<code>self</code>","text":"<p>While Rye is written in Rust, it uses a lot of Python tools internally.  These are maintained in an internal virtualenv stored in this location.</p>"},{"location":"guide/config/#py","title":"<code>py</code>","text":"<p>In this folder Rye stores the different toolchains.  Normally those are folders containing downloaded Python distributions, but they can also be symlinks or special reference files.</p>"},{"location":"guide/config/#shims","title":"<code>shims</code>","text":"<p>This folder contains shim binaries.  These binaries are for instance the <code>python</code> executable which automatically proxies to the current virtualenv or globally installed tools.</p>"},{"location":"guide/config/#config-file","title":"Config File","text":"<p>The config file <code>config.toml</code> in the <code>.rye</code> folder today is only used to manage defaults.  This is a fully annotated config file:</p> <pre><code>[default]\n# This is the default value that is written into new pyproject.toml\n# files for the `project.requires-python` key\nrequires-python = \"&gt;= 3.8\"\n\n# This is the default toolchain that is used\ntoolchain = \"cpython@3.11.1\"\n\n# This is the default build system that is used\nbuild-system = \"hatchling\"\n\n# This is the default license that is used\nlicense = \"MIT\"\n\n# This sets the default author (overrides the defaults from git).  The\n# format here is \"Name &lt;email&gt;\".\nauthor = \"Full Name &lt;email@address.invalid&gt;\"\n\n# The dependency operator to use by default for dependencies.  The options are\n# '&gt;=', '~=', and '=='.  The default currently is '&gt;='.  This affects the behavior\n# of `rye add`.\ndependency-operator = \"&gt;=\"\n\n[proxy]\n# the proxy to use for HTTP (overridden by the http_proxy environment variable)\nhttp = \"http://127.0.0.1:4000\"\n# the proxy to use for HTTPS (overridden by the https_proxy environment variable)\nhttps = \"http://127.0.0.1:4000\"\n\n[behavior]\n# When set to `true` the `managed` flag is always assumed to be `true`.\nforce-rye-managed = false\n\n# Enables global shims when set to `true`.  This means that the installed\n# `python` shim will resolve to a Rye-managed toolchain even outside of\n# virtual environments.\nglobal-python = false\n\n# Enable or disable automatic `sync` after `add` and `remove`.  This defaults\n# to `true` when uv is enabled and `false` otherwise.\nautosync = true\n\n# Marks the managed .venv in a way that cloud-based synchronization systems\n# like Dropbox and iCloud Files will not upload it.  This defaults to `true`\n# as a .venv in cloud storage typically does not make sense.  Set this to\n# `false` to disable this behavior.\nvenv-mark-sync-ignore = true\n\n# When set to `true` Rye will fetch certain interpreters with build information.\n# This will increase the space requirements, will put the interpreter into an\n# extra folder called `./install/` and place build artifacts adjacent in `./build`.\nfetch-with-build-info = false\n\n# An array of tables with optional sources.  Same format as in pyproject.toml\n[[sources]]\nname = \"default\"\nurl = \"https://pypi.org/simple/\"\n</code></pre>"},{"location":"guide/config/#manipulating-config","title":"Manipulating Config","text":"<p>new in 0.9.0</p> <p>The configuration can be read and modified with <code>rye config</code>.  The keys are in dotted notation.  <code>--get</code> reads a key, <code>--set</code>, <code>--set-int</code>, <code>--set-bool</code>, and <code>--unset</code> modify one.</p> <pre><code>rye config --set proxy.http=http://127.0.0.1:4000\nrye config --set-bool behavior.force-rye-managed=true\nrye config --get default.requires-python\n</code></pre> <p>For more information see <code>config</code>.</p>"},{"location":"guide/config/#per-project-config","title":"Per Project Config","text":"<p>For the project-specific <code>pyproject.toml</code> config see pyproject.toml.</p>"},{"location":"guide/deps/","title":"Dependencies","text":"<p>Dependencies are declared in pyproject.toml however adding them can be simplified with the <code>rye add</code> command.  In the most simple invocation it adds a regular dependency, but it can be customized.</p>"},{"location":"guide/deps/#adding-basic-dependency","title":"Adding Basic Dependency","text":"<p>To add a regular dependency just invoke <code>rye add</code> with the name of the Python package:</p> <pre><code>rye add Flask\n</code></pre> <p>If you also want to define a version, use a PEP 508 requirement:</p> <pre><code>rye add \"Flask&gt;=2.0\"\n</code></pre> <p>For extra/feature dependencies you can either use PEP 508 syntax or use <code>--features</code>:</p> <pre><code>rye add \"Flask[dotenv]\"\nrye add Flask --features=dotenv\n</code></pre> <p>These dependencies are stored in <code>project.dependencies</code>.</p> <p>Note about pre-releases</p> <p>By default <code>add</code> will not consider pre-releases.  This means if you add a dependency that has <code>.dev</code> or similar in the version number you will not find a match.  To consider them, add them with <code>--pre</code>:</p> <pre><code>rye add \"Flask==2.0.0rc2\" --pre\n</code></pre>"},{"location":"guide/deps/#development-dependencies","title":"Development Dependencies","text":"<p>For dependencies that should only be installed during development pass <code>--dev</code></p> <pre><code>rye add --dev black\n</code></pre> <p>These dependencies are stored in the non-standard <code>tool.rye.dev-dependencies</code> key.</p> <p>To run tools added this way without enabling the virtualenv use <code>rye run</code>:</p> <pre><code>rye run black\n</code></pre>"},{"location":"guide/deps/#git-local-dependencies","title":"Git / Local Dependencies","text":"<p>To add a local or git dependency, you can pass additional parameters like <code>--path</code> or <code>--git</code>:</p> <pre><code>rye add Flask --git=https://github.com/pallets/flask\nrye add My-Utility --path ./my-utility\n</code></pre> <p>Note that when adding such dependencies, it's necessary to also provide the name of the package.  Additionally for git dependencies all kinds of extra parameters such as <code>--tag</code>, <code>--rev</code> or <code>--branch</code> are supported.</p> <p>When working with local dependencies it's strongly encouraged to configure a workspace.</p>"},{"location":"guide/docker/","title":"Building a Container with Docker","text":"<p>If you want to put your Python code into a container, you probably have some server code that you don't submit to PyPI or another registry. If that's the case, read on. Else, skip to the next section.</p> <p>This guide requires some familiarity with Docker and Dockerfiles.</p>"},{"location":"guide/docker/#container-from-source","title":"Container from Source","text":"<ol> <li> <p>Make sure that your project is set up as a virtual project.      This means that you can't install it, and it won't mark itself as a dependency.      If you need your project to be installable, go to the next section.</p> <ul> <li>Your <code>pyproject.toml</code> should contain <code>virtual = true</code> under the <code>[tool.rye]</code> section. If it's not there, add it and run <code>rye sync</code>.</li> <li>If you're just setting up a project, run <code>rye init --virtual</code> instead of <code>rye init</code>.</li> </ul> </li> <li> <p>Create a <code>Dockerfile</code> in your project root with the following content, using <code>uv</code>:</p> <pre><code>FROM python:slim\n\nRUN pip install uv\n\nWORKDIR /app\nCOPY requirements.lock ./\nRUN uv pip install --no-cache --system -r requirements.lock\n\nCOPY src .\nCMD python main.py\n</code></pre> <p>Or, using <code>pip</code>:</p> <pre><code>FROM python:slim\n\nWORKDIR /app\nCOPY requirements.lock ./\nRUN PYTHONDONTWRITEBYTECODE=1 pip install --no-cache-dir -r requirements.lock\n\nCOPY src .\nCMD python main.py\n</code></pre> </li> <li> <p>You can now build your image like this:</p> <pre><code>docker build .\n</code></pre> </li> </ol>"},{"location":"guide/docker/#dockerfile-adjustments","title":"Dockerfile Adjustments","text":"<p>The <code>Dockerfile</code>s in this guide are examples. Some adjustments you might want to make:</p> <ul> <li>The command (<code>CMD python src/main.py</code>) should point to your script.</li> <li>Adjust the base image (<code>FROM python:slim</code>):</li> <li>Prefer a tagged version that matches the one from your <code>.python-version</code> file, e.g. <code>FROM python:3.12.0-slim</code>.</li> <li>The <code>-slim</code> variants are generally a good tradeoff between image size and compatibility and should work fine for most workloads.    But you can also use <code>-alpine</code> for smaller images (but potential compatibility issues) or no suffix for ones that contain more system tools.</li> <li>If you need additional system packages, install them before copying your source code, i.e. before the line <code>COPY src .</code>.   When using Debian-based images (i.e. <code>-slim</code> or no-suffix variants), that could look like this:</li> </ul> <pre><code>RUN apt-get update \\\n&amp;&amp; apt-get install -y --no-install-recommends some-dependency another-dependency \\\n&amp;&amp; rm -rf /var/lib/apt/lists/*\n</code></pre>"},{"location":"guide/docker/#container-from-a-python-package","title":"Container from a Python Package","text":"<p>If your code is an installable package, it's recommended that you first build it, then install it inside your Docker image. This way you can be sure that the image is exactly the same as what a user installation would be.</p> <p>An example <code>Dockerfile</code> might look like this with <code>uv</code>:</p> <pre><code>FROM python:slim\nRUN pip install uv\nRUN --mount=source=dist,target=/dist uv pip install --no-cache /dist/*.whl\nCMD python -m my_package\n</code></pre> <p>To build your docker image, you'll have to first build your wheel, like this:</p> <pre><code>rye build --wheel --clean\ndocker build . --tag your-image-name\n</code></pre> <p>Note that this approach bundles your dependencies and code in a single layer. This might be nice for performance, but it also means that all dependencies are re-installed during every image build, and different versions won't share the disk space for the dependencies.</p> <p>The Dockerfile adjustments from the previous section apply.</p>"},{"location":"guide/docker/#explanations","title":"Explanations","text":"<p>Rye's lockfile standard is the <code>requirements.txt</code> format from <code>pip</code> (and used by <code>uv</code>), so you don't actually need <code>rye</code> in your container to be able to install dependencies. This makes the Dockerfile much simpler and avoids the necessity for multi-stage builds if small images are desired.</p> <p>The <code>--no-cache-dir</code> and <code>--no-cache</code> parameters, passed to <code>pip</code> and <code>uv</code> respectively, make the image smaller by not writing any temporary files. While caching can speed up subsequent builds, it's not necessary in a container where the image is built once and then used many times.</p> <p>Similarly, the <code>PYTHONDONTWRITEBYTECODE=1</code> environment variable is set to avoid writing <code>.pyc</code> files, which are not needed in a container. (<code>uv</code> skips writing <code>.pyc</code> files by default.) </p>"},{"location":"guide/faq/","title":"FAQ","text":"<p>This section should cover some commonly asked questions.  If you do not find an answer here, consider reaching out to the community.</p>"},{"location":"guide/faq/#how-do-i-install-pytorch","title":"How Do I Install PyTorch?","text":"<p>PyTorch requires setting up manual sources as it's not installed via PyPI.  These sources can be set up in <code>pyproject.toml</code> for a simple project or globally in the config.</p> <ul> <li> <p>Option 1: <code>pyproject.toml</code></p> <pre><code>[[tool.rye.sources]]\nname = \"pytorch\"\nurl = \"https://download.pytorch.org/whl/cpu\"\n</code></pre> </li> <li> <p>Option 2: <code>~/.rye/config.toml</code></p> <pre><code>[[sources]]\nname = \"pytorch\"\nurl = \"https://download.pytorch.org/whl/cpu\"\n</code></pre> </li> </ul> <p>Afterwards you can add pytorch as you would expect:</p> <pre><code>rye add torch torchvision torchaudio\n</code></pre>"},{"location":"guide/faq/#windows-developer-mode","title":"Windows Developer Mode","text":"<p>Rye does not require symlinks but it works significantly better with them.  On Windows support for symlinks is restricted to privileged accounts.  The reason for this is that Symlinks were a late addition to Windows and some applications are not developed with them in mind which can cause misbehavior or in the worst case security issues in those applications.  Symlinks support however is enabled when the \"developer mode\" is activated on modern Windows versions.  </p> <p>Enabling \"developer mode\" has changed in later version of Windows. For older versions:</p> <ol> <li>Press Win+I to open the settings</li> <li>In the settings dialog click on \"Privacy &amp; security\"</li> <li>In the \"Security\" section click on \"For developers\"</li> <li>Enable the toggle \"Developer Mode\"</li> <li>In the \"Use developer features\" dialog confirm by clicking \"Yes\".</li> </ol> <p>In more modern versions:</p> <ol> <li>Press Win+I to open the settings</li> <li>In the settings dialog click on \"System\"</li> <li>In the \"System\" section click on \"For developers\"</li> <li>Enable the toggle \"Developer Mode\"</li> <li>In the \"Use developer features\" dialog confirm by clicking \"Yes\".</li> </ol> What happens if I don't enable it? <p>Enabling symlinks is not strictly required as Rye automatically falls back to hardlinks and junction points.  However not having symlinks enabled will ultimately result in a worse user experience for the following reasons:</p> <ul> <li>Custom toolchain registration uses proxy files rather than actual symlinks which   means that the executables in the <code>.rye\\py</code> path are non executable.</li> <li>All shims will be installed as hardlinks.  This can cause issues when upgrading   Rye while Python is in use.  These hardlinks will also continue to point to older   Rye executables creating more hard drive usage.</li> <li>Virtualenvs will be created with copies rather than symlinks.</li> <li>Junction points are used where symlinks to directories are otherwise used.  Some   tools might accidentally not detect junction points which can cause deletion of   virtualenvs to accidentally also delete or destroy the toolchain behind it.</li> </ul>"},{"location":"guide/faq/#missing-shared-libraries-on-linux","title":"Missing Shared Libraries on Linux","text":"<p>The Python builds that Rye uses require a Linux installation compatible to the Linux Standard Base Core Specification (LSB).  Unfortunately not all Linux distributions are strictly adhering to that specification out of the box.  In particularly the library <code>libcrypt.so.1</code> is commonly not installed on certain Linux distributions but the <code>_crypt</code> standard library module depends on it. Depending on the Linux distributions you need to run different commands to resolve this:</p> <ul> <li>archlinux: <code>pacman -S libxcrypt-compat</code></li> <li>CentOS/RedHat: <code>dnf install libxcrypt-compat</code></li> </ul> <p>There have also been reports of an error being generated at installation time despite <code>libcrypt.so.1</code> being installed when a different <code>ldd</code> (eg: Homebrew) shadows the system one.  In that case try the installation again after giving the default one higher priority in the `PATH:</p> <pre><code>export PATH=\"/usr/bin:$PATH\"\ncurl -sSf https://rye.astral.sh/get | bash\n</code></pre>"},{"location":"guide/faq/#references-to-build-time-paths","title":"References to Build-Time Paths","text":"<p>The prefers using standalone Python builds.  As Python historically is not much accommodating to portable builds there are various limitations still with this approach.  One of them is that built Python distributions capture some absolute paths and other build-time configuration.  These file paths are then often used by build tools to invoke C compilers.  For instance you might run into a compiler error like <code>error: stdio.h: No such file or directory</code> when building C extensions.  There is no known solution to this problem today other than registering a non portable toolchain.</p> <p>This issue is inherited from <code>python-build-standalone</code> and more information can be found in the documentation: References to Build-Time Paths.  There is also an open  Rye issue for it: Issue #621.</p>"},{"location":"guide/faq/#tkinter-support","title":"TKinter Support","text":"<p>TKinter uses TCL behind the scenes.  Unfortunately this also means that some runtime support is required.  This runtime support is provided by the portable Python builds, however the way TCL is initialized on macOS and Linux won't find these files in virtualenvs.  Newer versions of Rye will automatically export the <code>TCL_LIBRARY</code> and <code>TK_LIBRARY</code> environment variables for you in a manner very similar to this:</p> <pre><code>import os\nimport sys\nos.environ[\"TCL_LIBRARY\"] = sys.base_prefix + \"/lib/tcl8.6\"\nos.environ[\"TK_LIBRARY\"] = sys.base_prefix + \"/lib/tk8.6\"\n</code></pre>"},{"location":"guide/faq/#python-interactive-prompt-input-messed-up","title":"Python Interactive Prompt Input Messed Up","text":"<p>The Python builds that Rye uses are compiled against <code>libedit</code> rather than <code>readline</code> for licensing reasons.  You might run into unicode issues on input as a result of this due to limitations in <code>libedit</code>.  In some cases though you might also discover that the backspace key does not work or arrow keys don't work as expected.  This can be because the terminfo database cannot be found.</p> <p>For solutions to this issue, read the behavior quirks guide in the Standalone Python Builds documentation for solutions.</p>"},{"location":"guide/faq/#can-i-use-rye-alongside-other-python-installations","title":"Can I use Rye Alongside Other Python Installations?","text":"<p>Rye given its experimental nature does not want to disrupt already existing Python workflows.  As such using it alongside other Python installations is intentionally supported.  Even if the Rye shims come first on the <code>PATH</code>, Rye will automatically resolve to a different Python installation on the search path when invoked in a folder that contains a non Rye managed project.</p> <p>As such the answer is a clear yes!</p>"},{"location":"guide/faq/#muslalpine-support","title":"Musl/Alpine Support","text":"<p>When bootstrapping it can happen that you are running into a confusing error like \"No such file or directory (os error 2)\".  This can happen on MUSL based Linux systems like Alpine.  The reason for this is that Rye downloads distribution independent Python interpreters which are not compatible with Linux systems that do not use glibc.  The solution today is to install Python via other means and to install Rye with a custom <code>RYE_TOOLCHAIN</code>.  For more information see Customized Installation</p>"},{"location":"guide/faq/#wheels-appear-to-be-missing-files","title":"Wheels Appear to be Missing Files","text":"<p>You might be encountering missing files in wheels when running <code>rye build</code> and you are using hatchling.  The reason for this is that <code>rye build</code> uses \"build\" behind the scenes to build wheels.  There are two build modes and in some cases the wheel is first built from an sdist.  So if your sdists does not include the necessary data files, the resulting wheel will also be incorrect.</p> <p>This can be corrected by adding the files to the <code>include</code> in the hatch config for sdists.  For instance the following lines added to <code>pyproject.toml</code> will add the data files in <code>my_package</code> and all the tests to the sdist from which the wheel is built:</p> <pre><code>[tool.hatch.build.targets.sdist]\ninclude = [\"src/my_package\", \"tests\"]\n</code></pre>"},{"location":"guide/faq/#can-i-relocate-virtualenvs","title":"Can I Relocate Virtualenvs?","text":"<p>Rye very intentionally places the virtualenv (<code>.venv</code>) in the root folder of the workspace.  Relocations of virtualenvs is not supported.  This is a very intentional decision so that tools do not need to deal with various complex alternatives and can rely on a simple algorithm to locate it.  This is a form of convention over configuration and can also assist editor integrations.</p> <p>There are some known downsides of this.  For instance if you are placing your projects in Dropbox, it would cause this folder to synchronize.  As a way to combat this, Rye will automatically mark the virtualenv with the necessary flags to disable cloud sync of known supported cloud synchronization systems.</p> <p>For override this behavior you can set the <code>behavior.venv-mark-sync-ignore</code> configuration key to <code>false</code>.</p>"},{"location":"guide/faq/#why-does-rye-contain-trojan-bearfoos","title":"Why Does Rye Contain Trojan \"Bearfoos\"?","text":"<p>Unfortunately Windows likes to complain that Rye contains the trojan \"Win32/Bearfoos.A!ml\". This seems to be something that happens to a few programs written in Rust every once in a while because the compiler spits out some bytes that have been associated with Trojans written in Rust.</p> <p>It can be ignored.  For more information see the discussion Windows Bearfoos virus associated with rye.</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>Rye is built in Rust.  It can either be manually compiled and installed or it can be installed from a binary distribution.  It has support for Linux, macOS and Windows.</p>"},{"location":"guide/installation/#installing-rye","title":"Installing Rye","text":"<p>Rye is installed per-user and self manages itself.  It will install itself into a folder in your home directory and manage itself there.</p> LinuxmacOSWindowsCompile Yourself <p>To install you can run a curl command which will install the right binary for your operating system and CPU architecture and install it:</p> <pre><code>curl -sSf https://rye.astral.sh/get | bash\n</code></pre> <p>Alternatively if you don't trust this approach, you can download the latest release binary.  On first run it will install itself.</p> <ul> <li>rye-x86_64-linux.gz Intel/AMD (x86-64).</li> <li>rye-aarch64-linux.gz for ARM64.</li> </ul> <pre><code>gunzip rye-x86_64-linux.gz\nchmod +x ./rye-x86_64-linux\n./rye-x86_64-linux\n</code></pre> <p>To install you can run a curl command which will install the right binary for your operating system and CPU architecture and install it:</p> <pre><code>curl -sSf https://rye.astral.sh/get | bash\n</code></pre> <p>Alternatively if you don't trust this approach, you can download the latest release binary.  On first run it will install itself.</p> <ul> <li>rye-aarch64-macos.gz for Apple Silicon (M1/M2/M3) (ARM64).</li> <li>rye-x86_64-macos.gz for Intel processors (x86-64).</li> </ul> <pre><code>gunzip rye-aarch64-macos.gz\nchmod +x ./rye-aarch64-macos\n./rye-aarch64-macos\n</code></pre> <p>To install Rye on windows download the latest release and run the binary.  Upon first run it will install itself.  Please note that it's strongly recommended to have \"Developer Mode\" activated when using Rye and before starting the installation.  Learn more.</p> <ul> <li>rye-x86_64-windows.exe for 64-bit (x86-64).</li> <li>rye-x86-windows.exe for 32-bit (x86).</li> </ul> <p>Note</p> <p>Rye does not yet use signed binaries which means that you will need to allow the execution of the downloaded executable.  If there is no obvious way to do so, click on \"More info\" on the error message that shows up and then on \"Run anyway\".</p> <p>Additionally sometimes a Trojan warning about \"Bearfoos\" is shown.  This is a false positive.  For more information see the discussion Windows Bearfoos virus associated with rye.</p> <p>You need to have Rust and Cargo installed.  If you don't have, you can use rustup to get them onto your machine.</p> <p>Afterwards you can install <code>Rye</code> via <code>cargo</code>:</p> <pre><code>cargo install --git https://github.com/astral-sh/rye rye\n</code></pre> <p>Rye will automatically download suitable Python toolchains as needed.  For more information about this read about toolchains.  To install a specific version download a binary directly from GitHub.</p>"},{"location":"guide/installation/#customized-installation","title":"Customized Installation","text":"<p>On some platforms there is some limited support for customizing the installation experience.  This for instance can be necessary on certain Linux environments such as Alpine where the Rye provided Python interpreter is not supported.</p> LinuxmacOSWindows <p> The install script that is piped to <code>bash</code> can be customized with some environment variables:</p> <code>RYE_VERSION</code> <p>Defaults to <code>latest</code>.  Can be set to an explicit version to install a specific one.</p> <code>RYE_INSTALL_OPTION</code> <p>Can optionally be set to <code>\"--yes\"</code> to skip all prompts.</p> <code>RYE_TOOLCHAIN</code> <p>Optionally this environment variable can be set to point to a Python interpreter that should be used as the internal interpreter.  If not provided a suitable interpreter is automatically downloaded.</p> <p>At present only CPython 3.9 to 3.12 are supported.</p> <code>RYE_TOOLCHAIN_VERSION</code> <p>For Rye 0.22 and later a specific Python version can be picked rather than the default.  This affects the internal toolchain version only. It's useful for Docker builds where you can set the internal toolchain to the same as your project to only fetch a single Python.</p> <p>At present only CPython 3.9 to 3.12 are supported.</p> <p>This for instance installs a specific version of Rye without asking questions:</p> <p><pre><code>curl -sSf https://rye.astral.sh/get | RYE_VERSION=\"0.4.0\" RYE_INSTALL_OPTION=\"--yes\" bash\n</code></pre> </p> <p> The install script that is piped to <code>bash</code> can be customized with some environment variables:</p> <code>RYE_VERSION</code> <p>Defaults to <code>latest</code>.  Can be set to an explicit version to install a specific one.</p> <code>RYE_INSTALL_OPTION</code> <p>Can optionally be set to <code>\"--yes\"</code> to skip all prompts.</p> <code>RYE_TOOLCHAIN</code> <p>Optionally this environment variable can be set to point to a Python interpreter that should be used as the internal interpreter.  If not provided a suitable interpreter is automatically downloaded.</p> <p>At present only CPython 3.9 to 3.12 are supported.</p> <code>RYE_TOOLCHAIN_VERSION</code> <p>For Rye 0.22 and later a specific Python version can be picked rather than the default.  This affects the internal toolchain version only. It's useful for Docker builds where you can set the internal toolchain to the same as your project to only fetch a single Python.</p> <p>At present only CPython 3.9 to 3.12 are supported.</p> <p>This for instance installs a specific version of Rye without asking questions:</p> <p><pre><code>curl -sSf https://rye.astral.sh/get | RYE_VERSION=\"0.4.0\" RYE_INSTALL_OPTION=\"--yes\" bash\n</code></pre> </p> <p>The Windows installer has limited support for customizations via environment variables.  To set these you need to run the installer from <code>cmd.exe</code>.</p> <code>RYE_TOOLCHAIN</code> <p>Optionally this environment variable can be set to point to a Python interpreter that should be used as the internal interpreter.  If not provided a suitable interpreter is automatically downloaded.</p> <p>At present only CPython 3.9 to 3.12 are supported.</p> <code>RYE_TOOLCHAIN_VERSION</code> <p>For Rye 0.22 and later a specific Python version can be picked rather than the default.  This affects the internal toolchain version only. It's useful for Docker builds where you can set the internal toolchain to the same as your project to only fetch a single Python.</p> <p>At present only CPython 3.9 to 3.12 are supported.</p> <p>This for instance installs Rye with a specific toolchain:</p> <pre><code>set RYE_TOOLCHAIN=%USERPROFILE%\\AppData\\Local\\Programs\\Python\\Python310\\python.exe\nrye-x86_64-windows.exe\n</code></pre>"},{"location":"guide/installation/#add-shims-to-path","title":"Add Shims to Path","text":"<p>Once <code>rye</code> is installed you need to add the <code>shims</code> folder into your <code>PATH</code>. This folder is a folder that contains \"shims\" which are executables that Rye manages for you as well as the <code>rye</code> executable itself.  For instance any Python installation managed by Rye will be available via a shim placed there.</p> <p>On macOS or Linux you can accomplish this by adding it to your <code>.profile</code> file or similar.  This step is technically optional but required if you want to be able to just type <code>python</code> or <code>rye</code> into the shell to pick up the current virtualenv's Python interpreter.  The installer will offer to do this for you automatically.  If you opt-out, or you run a custom shell you will need to do this manually.</p> BashZSHFishNushellUnix ShellsWindows <p>Rye ships an <code>env</code> file which should be sourced to update <code>PATH</code> automatically.</p> <pre><code>echo 'source \"$HOME/.rye/env\"' &gt;&gt; ~/.profile\n</code></pre> <p>In some setups <code>.profile</code> is not sourced, in which case you can add it to your <code>.bashrc</code>:</p> <pre><code>echo 'source \"$HOME/.rye/env\"' &gt;&gt; ~/.bashrc\n</code></pre> <p>Rye ships an <code>env</code> file which should be sourced to update <code>PATH</code> automatically.</p> <pre><code>echo 'source \"$HOME/.rye/env\"' &gt;&gt; ~/.zprofile\n</code></pre> <p>In some setups <code>.zprofile</code> is not sourced, in which case you can add it to your <code>.zshrc</code>:</p> <pre><code>echo 'source \"$HOME/.rye/env\"' &gt;&gt; ~/.zshrc\n</code></pre> <p>Since fish does not support <code>env</code> files, you need to add the shims directly.  This can be accomplished by running this command once:</p> <pre><code>set -Ua fish_user_paths \"$HOME/.rye/shims\"\n</code></pre> <p>Since nushell does not support <code>env</code> files, you need to add the shims directly.  This can be accomplished by adding this to your <code>env.nu</code> file:</p> <pre><code>$env.PATH = ($env.PATH | split row (char esep) | append \"~/.rye/shims\")\n</code></pre> <p>Rye ships an <code>env</code> file which should be sourced to update <code>PATH</code> automatically.</p> <pre><code>echo '. \"$HOME/.rye/env\"' &gt;&gt; ~/.profile\n</code></pre> <p>The windows installer normally will automatically register the rye path in the <code>PATH</code> environment variable.  If this does not work you will need to manually perform the following steps:</p> <ol> <li>Press Win+R, enter <code>sysdm.cpl</code> and hit Enter.</li> <li>In the \"System Properties\" dialog, click the \"Advanced\" tab.</li> <li>Click on \"Environment Variables\".</li> <li>In the top list, double click on the <code>Path</code> variable.</li> <li>In the \"Edit environment variable\" dialog click on \"New\".</li> <li>Enter <code>%USERPROFILE%\\.rye\\shims</code> and hit Enter.</li> <li>Click repeatedly on \"Move Up\" until the newly added item is at the top.</li> <li>Click on \"OK\" and close the dialog.</li> </ol> <p>Note that you might need to restart your login session for this to take effect.</p> <p>There is a quite a bit to shims and their behavior.  Make sure to read up on shims to learn more.</p>"},{"location":"guide/installation/#shell-completion","title":"Shell Completion","text":"<p>Rye supports generating completion scripts for Bash, Zsh, Fish, Powershell and Nushell. Here are some common locations for each shell:</p> BashZshFishPowershellNuShell <pre><code>mkdir -p ~/.local/share/bash-completion/completions\nrye self completion &gt; ~/.local/share/bash-completion/completions/rye.bash\n</code></pre> <pre><code># Make sure ~/.zfunc is added to fpath, before compinit.\nrye self completion -s zsh &gt; ~/.zfunc/_rye\n</code></pre> <p>Oh-My-Zsh:</p> <pre><code>mkdir $ZSH_CUSTOM/plugins/rye\nrye self completion -s zsh &gt; $ZSH_CUSTOM/plugins/rye/_rye\n</code></pre> <p>Then make sure rye plugin is enabled in ~/.zshrc</p> <pre><code>rye self completion -s fish &gt; ~/.config/fish/completions/rye.fish\n</code></pre> <pre><code># Create a directory to store completion scripts\nmkdir $PROFILE\\..\\Completions\necho @'\nGet-ChildItem \"$PROFILE\\..\\Completions\\\" | ForEach-Object {\n    . $_.FullName\n}\n'@ | Out-File -Append -Encoding utf8 $PROFILE\n# Generate script\nSet-ExecutionPolicy Unrestricted -Scope CurrentUser\nrye self completion -s powershell | Out-File -Encoding utf8 $PROFILE\\..\\Completions\\rye_completion.ps1\n</code></pre> <pre><code>rye self completion -s nushell | save --append $nu.env-path\n</code></pre>"},{"location":"guide/installation/#updating-rye","title":"Updating Rye","text":"<p>To update rye to the latest version you can use <code>rye</code> itself:</p> <pre><code>rye self update\n</code></pre>"},{"location":"guide/installation/#uninstalling","title":"Uninstalling","text":"<p>If you don't want to use Rye any more, you can ask it to uninstall it again:</p> <pre><code>rye self uninstall\n</code></pre> <p>Additionally you should delete the remaining <code>.rye</code> folder from your home directory and remove <code>.rye/shims</code> from the <code>PATH</code> again (usually by removing the code that sources the <code>env</code> file from the installation step).  Rye itself does not place any data in other locations.  Note though that virtual environments created by rye will no longer function after Rye was uninstalled.</p>"},{"location":"guide/installation/#preventing-auto-installation","title":"Preventing Auto Installation","text":"<p>Rye when launched will normally perform an auto installation.  This can be annoying in certain development situations.  This can be prevented by exporting the <code>RYE_NO_AUTO_INSTALL</code> environment variable.  It needs to be set to <code>1</code> to disable the feature.</p> LinuxmacOSWindows <pre><code>export RYE_NO_AUTO_INSTALL=1\n</code></pre> <pre><code>export RYE_NO_AUTO_INSTALL=1\n</code></pre> <pre><code>set RYE_NO_AUTO_INSTALL=1\n</code></pre>"},{"location":"guide/publish/","title":"Building and Publishing","text":"<p>Rye currently uses build to build the package and uses twine to publish it.</p>"},{"location":"guide/publish/#build","title":"Build","text":"<p>By default, <code>rye</code> will build both the sdist and wheel targets in the <code>dist</code> directory.   The command for this is called <code>build</code>.</p> <pre><code>rye build\n</code></pre> <p>You can use the <code>--sdist</code> or <code>--wheel</code> flag to build the specific target, or specify the output directory with <code>--out</code>.</p> <pre><code>rye build --wheel --out target\n</code></pre> <p>If you want to clean the build directory before building, run:</p> <pre><code>rye build --clean\n</code></pre>"},{"location":"guide/publish/#publish","title":"Publish","text":"<p>Rye will publish the distribution files under the <code>dist</code> directory to PyPI by default.</p> <pre><code>rye publish\n</code></pre> <p>You might be asked to input your access token and some other info if needed.</p> <pre><code>No access token found, generate one at: https://pypi.org/manage/account/token/\nAccess token:\n</code></pre> <p>You can also specify the distribution files to be published:</p> <pre><code>rye publish dist/example-0.1.0.tar.gz\n</code></pre>"},{"location":"guide/publish/#-repository","title":"--repository","text":"<p>Rye supports publishing the package to a different repository by using the <code>--repository</code> and <code>--repository-url</code> flags. For example, to publish to the test PyPI repository:</p> <pre><code>rye publish --repository testpypi --repository-url https://test.pypi.org/legacy/\n</code></pre>"},{"location":"guide/publish/#-yes","title":"--yes","text":"<p>You can optionally set the <code>--yes</code> flag to skip the confirmation prompt. This can be useful for CI/CD pipelines.</p> <pre><code>rye publish --token &lt;your_token&gt; --yes\n</code></pre> <p>Rye will store your repository info in <code>$HOME/.rye/credentials</code> for future use.</p>"},{"location":"guide/publish/#-skip-existing","title":"--skip-existing","text":"<p>You can use <code>--skip-existing</code> to skip any distribution files that have already been published to the repository. Note that some repositories may not support this feature.</p>"},{"location":"guide/pyproject/","title":"Python Project (<code>pyproject.toml</code>)","text":"<p>Rye tries to avoid a lot of proprietary configuration in the <code>pyproject.toml</code> file but a bit is necessary.  Here are the most important keys that Rye expects:</p>"},{"location":"guide/pyproject/#projectdependencies","title":"<code>project.dependencies</code>","text":"<p>This key is used to manage dependencies.  They work exactly like you expect from a regular <code>pyproject.toml</code> file and in fact Rye changes nothing about this.  However Rye is capable of modifying these entries with the <code>rye add</code> and <code>rye remove</code> commands.</p> <pre><code>[project]\ndependencies = [\n\"mkdocs~=1.4.3\",\n\"mkdocs-material~=9.1.12\",\n\"pymdown-extensions~=9.11\",\n]\n</code></pre>"},{"location":"guide/pyproject/#projectscripts","title":"<code>project.scripts</code>","text":"<p>This key specifies the scripts that are to be generated and installed into the virtual environment during <code>sync</code>. These scripts will invoke the configured entry point.</p> <p><pre><code>[project.scripts]\nmy-hello-script = 'hello:main'\n</code></pre> This configuration will generate a script <code>my-hello-script</code> that will call the <code>main</code> function of the <code>hello</code> module.</p> <p>Scripts can be installed using <code>rye sync</code> and run using <code>rye run</code>:</p> <pre><code>$ rye sync\n$ rye run my-hello-script\nHello from hello!\n</code></pre>"},{"location":"guide/pyproject/#toolryedev-dependencies","title":"<code>tool.rye.dev-dependencies</code>","text":"<p>This works similar to <code>project.dependencies</code> but holds development only dependencies.  These can be added here automatically via <code>rye add --dev</code>.</p> <pre><code>[tool.rye]\ndev-dependencies = [\"black~=23.3.0\"]\n</code></pre> <p>Dev dependencies are installed automatically unless <code>--no-dev</code> is passed to <code>sync</code>.</p>"},{"location":"guide/pyproject/#toolryeexcluded-dependencies","title":"<code>tool.rye.excluded-dependencies</code>","text":"<p>This is a special key that contains dependencies which are never installed, even if they are pulled in as indirect dependencies.  These are added here automatically with <code>rye add --excluded</code>.</p> <pre><code>[tool.rye]\nexcluded-dependencies = [\"cffi\"]\n</code></pre>"},{"location":"guide/pyproject/#toolryeuniversal","title":"<code>tool.rye.universal</code>","text":"<p>new in 0.36.0</p> <p>When this flag is enabled all <code>lock</code> and <code>sync</code> operations in the project or workspace operate as if <code>--universal</code> is passed.  This means that the dependency resolver will attempt to generate a resolution that's valid on all platforms, operating systems, and architectures, rather than a resolution that's specific to the current platform.</p> <pre><code>[tool.rye]\nuniversal = true\n</code></pre>"},{"location":"guide/pyproject/#toolryegenerate-hashes","title":"<code>tool.rye.generate-hashes</code>","text":"<p>new in 0.35.0</p> <p>When this flag is enabled all <code>lock</code> and <code>sync</code> operations in the project or workspace operate as if <code>--generate-hashes</code> is passed.  This means that all dependencies in all lock files will include a hash.</p> <pre><code>[tool.rye]\ngenerate-hashes = true\n</code></pre>"},{"location":"guide/pyproject/#toolryelock-with-sources","title":"<code>tool.rye.lock-with-sources</code>","text":"<p>new in 0.18.0</p> <p>When this flag is enabled all <code>lock</code> and <code>sync</code> operations in the project or workspace operate as if <code>--with-sources</code> is passed.  This means that all lock files contain the full source references.  Note that this can create lock files that contain credentials if the sources have credentials included in the URL.</p> <pre><code>[tool.rye]\nlock-with-sources = true\n</code></pre>"},{"location":"guide/pyproject/#toolryemanaged","title":"<code>tool.rye.managed</code>","text":"<p>new in 0.3.0</p> <p>This key tells rye that this project is supposed to be managed by Rye.  This key primarily affects some automatic creation of virtualenvs.  For instance Rye will not try to initialize a virtualenv when using shims without this flag.  It can be forced enabled in the global config.</p> <pre><code>[tool.rye]\nmanaged = true\n</code></pre>"},{"location":"guide/pyproject/#toolryevirtual","title":"<code>tool.rye.virtual</code>","text":"<p>new in 0.20.0</p> <p>If this key is set to <code>true</code> the project is declared as a virtual project.  This is a special mode in which the package itself is not installed, but only the dependencies are.  This is for instance useful if you are not creating a Python project, but you are depending on Python software.  As an example you can use this to install software written in Python.  This key is set to true when <code>rye init</code> is invoked with the <code>--virtual</code> flag.</p> <pre><code>[tool.rye]\nvirtual = true\n</code></pre> <p>For more information consult the Virtual Project Guide.</p>"},{"location":"guide/pyproject/#toolryesources","title":"<code>tool.rye.sources</code>","text":"<p>This is an array of tables with sources that should be used for locating dependencies. This lets you use indexes other than PyPI.  These sources can also be configured in the main <code>config.toml</code> config file with the same syntax.</p> <pre><code>[[tool.rye.sources]]\nname = \"default\"\nurl = \"http://pypi.org/simple/\"\n</code></pre> <p>For more information about configuring sources see Dependency Sources.</p>"},{"location":"guide/pyproject/#toolryescripts","title":"<code>tool.rye.scripts</code>","text":"<p>This key can be used to register custom scripts that are exposed via <code>rye run</code>.  Each key is a script, and each value is the configuration for that script.  Normally the value is an object with different keys with the most important key being <code>cmd</code> which holds the command to execute. However if only <code>cmd</code> is set, then the object is optional.  <code>cmd</code> itself can either be set to a string or an array of arguments.</p> <pre><code>[tool.rye.scripts]\n# These three options are equivalent:\ndevserver = \"flask run --app ./hello.py --debug\"\ndevserver-alt = [\"flask\", \"run\", \"--app\", \"./hello.py\", \"--debug\"]\ndevserver-explicit = { cmd = \"flask run --app ./hello.py --debug\" }\n</code></pre> <p>The following keys are possible for a script:</p>"},{"location":"guide/pyproject/#cmd","title":"<code>cmd</code>","text":"<p>The command to execute.  This is either a <code>string</code> or an <code>array</code> of arguments.  In either case shell specific interpolation is unavailable.  The command will invoke one of the tools in the virtualenv if it's available there.</p> <pre><code>[tool.rye.scripts]\ndevserver = { cmd = \"flask run --app ./hello.py --debug\" }\nhttp = { cmd = [\"python\", \"-mhttp.server\", \"8000\"] }\n</code></pre>"},{"location":"guide/pyproject/#env","title":"<code>env</code>","text":"<p>This key can be used to provide environment variables with a script:</p> <pre><code>[tool.rye.scripts]\ndevserver = { cmd = \"flask run --debug\", env = { FLASK_APP = \"./hello.py\" } }\n</code></pre>"},{"location":"guide/pyproject/#env-file","title":"<code>env-file</code>","text":"<p>new in 0.30.0</p> <p>This is similar to <code>env</code> but rather than setting environment variables directly, it instead points to a file that should be loaded (relative to the <code>pyproject.toml</code>):</p> <pre><code>[tool.rye.scripts]\ndevserver = { cmd = \"flask run --debug\", env-file = \".dev.env\" }\n</code></pre>"},{"location":"guide/pyproject/#chain","title":"<code>chain</code>","text":"<p>This is a special key that can be set instead of <code>cmd</code> to make a command invoke multiple other commands.  Each command will be executed one after another.  If any of the commands fails, the rest of the commands won't be executed and the chain fails.</p> <pre><code>[tool.rye.scripts]\nlint = { chain = [\"lint:black\", \"lint:flake8\" ] }\n\"lint:black\" = \"black --check src\"\n\"lint:flake8\" = \"flake8 src\"\n</code></pre>"},{"location":"guide/pyproject/#call","title":"<code>call</code>","text":"<p>This is a special key that can be set instead of <code>cmd</code> to make a command invoke python functions or modules.  The format is one of the three following formats:</p> <ul> <li><code>&lt;module_name&gt;</code>: equivalent to <code>python -m &lt;module_name&gt;</code></li> <li><code>&lt;module_name&gt;:&lt;function_name&gt;</code>: runs <code>&lt;function_name&gt;</code> from <code>&lt;module_name&gt;</code> and exits with the return value</li> <li><code>&lt;module_name&gt;:&lt;function_name&gt;(&lt;args&gt;)</code>: passes specific arguments to the function</li> </ul> <p>Extra arguments provided on the command line are passed in <code>sys.argv</code>.</p> <pre><code>[tool.rye.scripts]\nserve = { call = \"http.server\" }\nhelp = { call = \"builtins:help\" }\nhello-world = { call = \"builtins:print('Hello World!')\" }\n</code></pre>"},{"location":"guide/pyproject/#toolryeworkspace","title":"<code>tool.rye.workspace</code>","text":"<p>When a table with that key is stored, then a project is declared to be a workspace root.  By default all Python projects discovered in sub folders will then become members of this workspace and share a virtualenv. Optionally the <code>members</code> key (an array) can be used to restrict these members. In that list globs can be used.  The root project itself is always a member.</p> <pre><code>[tool.rye.workspace]\nmembers = [\"mylib-*\"]\n</code></pre> <p>For more information consult the Workspaces Guide.</p>"},{"location":"guide/rust/","title":"Rust Modules","text":"<p>Rye recommends using maturin to develop Rust Python extension modules.  This process is largely automated and new projects can be created with <code>rye init</code>.</p>"},{"location":"guide/rust/#new-project","title":"New Project","text":"<pre><code>rye init my-project --build-system maturin\ncd my-project\n</code></pre> <p>The following structure will be created:</p> <pre><code>.\n\u251c\u2500\u2500 .git\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .python-version\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 python\n    \u2514\u2500\u2500 my_project\n        \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 lib.rs\n</code></pre>"},{"location":"guide/rust/#iterating","title":"Iterating","text":"<p>When you use maturin as a build system then <code>rye sync</code> will automatically build the rust extension module into your venv.  Likewise <code>rye build</code> will use maturin to trigger a wheel build.  For faster iteration it's recommended to use <code>maturin</code> directly.</p> <p>If you want to use other maturin commands such as <code>maturin develop</code> you can install it as a global tool:</p> <pre><code>rye install maturin\n</code></pre> <p>Rye recommends mixed python/rust modules.  In that case you can save some valuable iteration time by running <code>maturin develop --skip-install</code>:</p> <pre><code>maturin develop --skip-install\n</code></pre>"},{"location":"guide/shims/","title":"Shims","text":"<p>After installation Rye places two shims on your <code>PATH</code>: <code>python</code> and <code>python3</code>.  These shims have specific behavior that changes depending on if they are used within a Rye managed project or outside.</p> <p>Inside a Rye managed project they resolve to the Python interpreter of the virtualenv. This means that even if you do not enable the virtualenv, you can just run <code>python</code> in a shell, and it will automatically operate in the right environment.</p> <p>Outside a Rye managed project it typically resolves to your system Python, though you can also opt to have it resolve to a Rye managed Python installation for you.  This is done so that it's not disruptive to your existing workflows which might depend on the System python installation.</p>"},{"location":"guide/shims/#global-shims","title":"Global Shims","text":"<p>new in 0.9.0</p> <p>To enable global shims, you need to enable the <code>global-python</code> flag in the <code>config.toml</code> file:</p> <pre><code>rye config --set-bool behavior.global-python=true\n</code></pre> <p>Afterwards if you run <code>python</code> outside of a Rye managed project it will spawn a Python interpreter that is shipped with Rye.  It will honor the closest <code>.python-version</code> file for you.  Additionally you can also explicitly request a specific Python version by adding <code>+VERSION</code> after the <code>python</code> command.  For instance this runs a script with Python 3.8:</p> <pre><code>python +3.8 my-script.py\n</code></pre> <p>Note</p> <p>Selecting a specific Python version this way only works outside of Rye managed projects.  Within Rye managed projects, the version needs to be explicitly selected via <code>.python-version</code> or with the <code>requires-python</code> key in <code>pyproject.toml</code>.</p>"},{"location":"guide/sources/","title":"Dependency Sources","text":"<p>new in 0.2.0</p> <p>Normally Rye loads packages from PyPI only.  However it is possible to instruct it to load packages from other indexes as well.</p>"},{"location":"guide/sources/#adding-a-source","title":"Adding a Source","text":"<p>An index can be added to a project or workspace (via <code>pyproject.toml</code>) or into the global config.  Rye will always consult both files where the <code>pyproject.toml</code> file wins over the global config.</p> <p>Each source needs to have a unique name.  The default source is always called <code>default</code> and out of the box points to PyPI.</p> Global SourceProject Source <p>Add this to <code>~/.rye/config.toml</code>:</p> <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/simple/\"\n</code></pre> <p>Add this to <code>pyproject.toml</code>:</p> <pre><code>[[tool.rye.sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/simple/\"\n</code></pre> <p>changed in 0.4.0</p> <p>Sources in the global config are also considered for tool installations.</p>"},{"location":"guide/sources/#index-types","title":"Index Types","text":"<p>Rye supports different types of sources and also allows overriding the <code>default</code> PyPI index.  If you give another source the name <code>default</code>, PyPI will no longer be used for resolution.</p> Regular IndexFind LinksDefault Index <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/simple/\"\ntype = \"index\"  # this is implied\n</code></pre> <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/\"\ntype = \"find-links\"\n</code></pre> <pre><code>[[sources]]\nname = \"default\"\nurl = \"https://company.internal/simple/\"\n</code></pre> <p>Warning</p> <p>Please take note that the default index cannot be of type <code>find-links</code>.</p>"},{"location":"guide/sources/#source-types","title":"Source Types","text":"<p>The two sources types (<code>index</code> vs <code>find-links</code>) are determined by the underlying pip infrastructure:</p>"},{"location":"guide/sources/#index","title":"<code>index</code>","text":"<p>This is a PEP 503 type index as provided by tools such as PyPI or devpi.  It corresponds to the arguments <code>--index-url</code> or <code>--extra-index-url</code> in pip.</p> <p>Note: see the <code>uv</code> documentation for more on the use of multiple indexes.</p>"},{"location":"guide/sources/#find-links","title":"<code>find-links</code>","text":"<p>This is a source that can be of a variety of types and has to point to a file path or hosted HTML page linking to packages.  It corresponds to the <code>--find-links</code> argument.  The format of the HTML page is somewhat underspecified but generally all HTML links pointing to <code>.tar.gz</code> or <code>.whl</code> files are considered.</p>"},{"location":"guide/sources/#index-authentication","title":"Index Authentication","text":"<p>HTTP basic auth is supported for index authentication.  It can be supplied in two ways.  <code>username</code> and <code>password</code> can be directly embedded in the config, or they can be supplied with environment variables.</p> Configured CredentialsEnvironment Variables <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://company.internal/simple/\"\nusername = \"username\"\npassword = \"super secret\"\n</code></pre> <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"https://${INDEX_USERNAME}:${INDEX_PASSWORD}@company.internal/simple/\"\n</code></pre>"},{"location":"guide/sources/#ssltls-verification","title":"SSL/TLS Verification","text":"<p>By default a source needs to be SSL/TLS protected.  If not, rye will refuse to honor the source.  You can override this by setting <code>verify-ssl</code> to <code>false</code>:</p> <pre><code>[[sources]]\nname = \"company-internal\"\nurl = \"http://company.internal/simple/\"\nverify-ssl = false\n</code></pre>"},{"location":"guide/sync/","title":"Syncing and Locking","text":"<p>Rye uses <code>uv</code> to manage dependencies.</p> <p>In order to download dependencies rye creates two \"lockfiles\" (called <code>requirements.lock</code> and <code>requirements-dev.lock</code>).  These are not real lockfiles, but they fulfill a similar purpose until a better solution has been implemented.</p> <p>Whenever <code>rye sync</code> is called, it will update lockfiles as well as the virtualenv.  If you only want to update the lockfiles, then <code>rye lock</code> can be used.</p>"},{"location":"guide/sync/#lock","title":"Lock","text":"<p>When locking, some options can be provided to change the locking behavior.  These flags are also all available on <code>rye sync</code>.</p>"},{"location":"guide/sync/#-update-update-all","title":"<code>--update</code> / <code>--update-all</code>","text":"<p>Updates a specific or all requirements to the latest and greatest version.  Without this flag a dependency will only be updated if necessary.</p> <pre><code>rye lock --update-all\n</code></pre>"},{"location":"guide/sync/#-features-all-features","title":"<code>--features</code> / <code>--all-features</code>","text":"<p>Python packages can have extra dependencies.  By default the local package that is installed will only be installed with the default features.  If for instance you have an extra dependency this will only be installed if the feature is enabled.</p> <pre><code>rye add --optional=web flask\nrye lock --features=web\n</code></pre> <p>When working with workspaces, the package name needs to be prefixed with a slash:</p> <pre><code>rye lock --features=package-name/feature-name\n</code></pre> <p>The <code>--features</code> parameter can be passed multiple times and features can also be comma separated.  To turn on all features, the <code>--all-features</code> parameter can be used.</p> <pre><code>rye lock --all-features\n</code></pre>"},{"location":"guide/sync/#-pre","title":"<code>--pre</code>","text":"<p>By default updates and version resolution will not consider pre-releases of packages.  If you do want to include those, pass <code>--pre</code></p> <pre><code>rye lock Flask --pre\n</code></pre>"},{"location":"guide/sync/#-with-sources","title":"<code>--with-sources</code>","text":"<p>new in 0.18.0</p> <p>By default (unless the <code>tool.rye.lock-with-sources</code> config key is set to <code>true</code> in the <code>pyproject.toml</code>) lockfiles are not generated with source references.  This means that if custom sources are used the lockfile cannot be installed via <code>uv</code> or <code>pip</code>, unless <code>--find-links</code> and other parameters are manually passed.  This can be particularly useful when the lockfile is used for Docker image builds.</p> <p>When this flag is passed then the lockfile is generated with references to <code>--index-url</code>, <code>--extra-index-url</code> or <code>--find-links</code>.</p> <pre><code>rye lock --with-sources\n</code></pre>"},{"location":"guide/sync/#sync","title":"Sync","text":"<p>Syncing takes the same parameters as <code>lock</code> and then some.  Sync will usually first do what <code>lock</code> does and then use the lockfiles to update the virtualenv.</p>"},{"location":"guide/sync/#-no-lock","title":"<code>--no-lock</code>","text":"<p>To prevent the lock step from automatically running, pass <code>--no-lock</code>.</p> <pre><code>rye sync --no-lock\n</code></pre>"},{"location":"guide/sync/#-no-dev","title":"<code>--no-dev</code>","text":"<p>Only sync based on the production lockfile (<code>requirements.lock</code>) instead of the development lockfile (<code>requirements-dev.lock</code>).</p> <pre><code>rye sync --no-dev\n</code></pre>"},{"location":"guide/sync/#platform-compatibility","title":"Platform Compatibility","text":"<p>By default, lockfiles depend on the platform they were generated on.</p> <p>For example, if your project relies on platform-specific packages and you generate lockfiles on Windows, these lockfiles will include Windows-specific projects. Consequently, they won't be compatible with other platforms like Linux or macOS.</p> <p>To generate a cross-platform lockfile, you can enable uv's <code>universal</code> setting by adding the following to your <code>pyproject.toml</code>:</p> <pre><code>[tool.rye]\nuniversal = true\n</code></pre>"},{"location":"guide/tools/","title":"Tools","text":"<p>Rye supports global tool installations.  This for instance allows you to install tools like <code>black</code> or <code>ruff</code> globally.</p>"},{"location":"guide/tools/#installing-tools","title":"Installing Tools","text":"<p>Use the <code>rye tools install</code> (aliased to <code>rye install</code>) command to install a tool globally with a shim:</p> <pre><code>rye install ruff\n</code></pre> <p>Afterwards the tool is installed into <code>~/.rye/tools/ruff</code> and the necessary shims are placed in <code>~/.rye/shims</code>.</p> <p>changed in 0.4.0</p> <p>The <code>install</code> command now considers custom sources configured in the <code>config.toml</code> file.  For more information see Dependency Sources.</p>"},{"location":"guide/tools/#extra-requirements","title":"Extra Requirements","text":"<p>Some tools do not declare all of their dependencies since they might be optional. In some cases these can be declared by passing extra features to the installer:</p> <pre><code>rye install black --features colorama\n</code></pre> <p>If dependencies are not at all specified, then they can be provided with <code>--extra-requirement</code>. This is particularly sometimes necessary if the tool uses <code>pkg_resources</code> (part of <code>setuptools</code>) but forgets to declare that dependency:</p> <pre><code>rye install gradio --extra-requirement setuptools\n</code></pre>"},{"location":"guide/tools/#listing-tools","title":"Listing Tools","text":"<p>If you want to see which tools are installed, you can use <code>rye tools list</code>:</p> <pre><code>rye tools list\n</code></pre> <pre><code>black\n  black\n  blackd\nruff\n  ruff\n</code></pre> <p>To also see which scripts those tools provide, also pass <code>--include-scripts</code></p> <pre><code>rye tools list --include-scripts\n</code></pre>"},{"location":"guide/tools/#uninstalling-tools","title":"Uninstalling Tools","text":"<p>To uninstall a tool again, use <code>rye tools uninstall</code> (aliased to <code>rye uninstall</code>):</p> <pre><code>rye uninstall black\n</code></pre>"},{"location":"guide/virtual/","title":"Virtual Projects","text":"<p>new in 0.20.0</p> <p>Virtual projects are projects which are themselves not installable Python packages, but that will sync their dependencies.  They are declared like a normal python package in a <code>pyproject.toml</code>, but they do not create a package. Instead the <code>tool.rye.virtual</code> key is set to <code>true</code>.</p> <p>For instance this is useful if you want to use a program like <code>mkdocs</code> without declaring a package yourself:</p> <pre><code>rye init --virtual\nrye add mkdocs\nrye sync\nrye run mkdocs\n</code></pre> <p>This will create a <code>pyproject.toml</code> but does not actually declare any python code itself. Yet when syncing you will end up with mkdocs in your project.</p>"},{"location":"guide/virtual/#behavior-changes","title":"Behavior Changes","text":"<p>When syncing the project itself is never installed into the virtualenv as it's not considered to be a valid package.  Likewise you cannot publish virtual packages to PyPI or another index.</p>"},{"location":"guide/virtual/#limitations","title":"Limitations","text":"<p>Virtual projects can not have optional dependencies.  These even if declared are not installed.</p>"},{"location":"guide/virtual/#workspaces","title":"Workspaces","text":"<p>If a workspace does not have a toplevel package it's recommended that it's declared as virtual.</p>"},{"location":"guide/workspaces/","title":"Workspaces","text":"<p>Workspaces are a feature that allows you to work with multiple packages that have dependencies on each other.  A workspace is declared by setting the <code>tool.rye.workspace</code> key in <code>pyproject.toml</code>.  Afterwards, all projects within that workspace share a singular virtualenv.</p>"},{"location":"guide/workspaces/#declaring-workspaces","title":"Declaring Workspaces","text":"<p>A workspace is declared in the \"toplevel\" <code>pyproject.toml</code>.  At the very least the key <code>tool.rye.workspace</code> needs to be added.  It's also recommended to set a glob pattern in the <code>members</code> key to prevent accidentally including unintended folders as projects.</p> <pre><code>[tool.rye.workspace]\nmembers = [\"myname-*\"]\n</code></pre> <p>This declares a workspace where all folders starting with the name <code>myname-</code> are considered.  If the toplevel workspace itself should not be a project, then it should be declared as a virtual package:</p> <pre><code>[tool.rye]\nvirtual = true\n\n[tool.rye.workspace]\nmembers = [\"myname-*\"]\n</code></pre> <p>For more information on that, see Virtual Packages.</p>"},{"location":"guide/workspaces/#syncing","title":"Syncing","text":"<p>In a workspace, it does not matter which project you are working with, the entire workspace is synchronized at all times.  This has some atypical consequences but simplifies the general development workflow.</p> <p>When a package depends on another package it's first located in the workspace locally before it's attempted to be downloaded from an index.  The <code>--all-features</code> flag is automatically applied to all packages, but to turn on the feature of a specific package the feature name must be prefixed.  For instance to enable the <code>foo</code> extra feature of the <code>myname-bar</code> package you would need to do this:</p> <pre><code>rye sync --features=myname-bar/foo\n</code></pre>"},{"location":"guide/commands/","title":"Commands","text":"<p>This is a list of all the commands that rye provides:</p> <ul> <li>add: Adds a Python package to this project</li> <li>build: Builds a package for distribution</li> <li>config: Reads or updates the Rye configuration</li> <li>fetch: Fetches a Python interpreter for the local machine (alias)</li> <li>fmt: Run the code formatter on the project</li> <li>init: Initializes a new project</li> <li>install: Installs a global tool (alias)</li> <li>lock: Updates the lockfiles without installing dependencies</li> <li>lint: Run the linter on the project</li> <li>make-req: Builds and prints a PEP 508 requirement string from parts</li> <li>pin: Pins a Python version to the project</li> <li>publish: Publish packages to a package repository</li> <li>remove: Remove a dependency from this project</li> <li>run: Runs a command installed into this package</li> <li>show: Prints the current state of the project</li> <li>sync: Updates the virtualenv based on the pyproject.toml</li> <li>test: Runs the project's tests</li> <li>toolchain: Helper utility to manage Python toolchains</li> <li>tools: Helper utility to manage global tools.</li> <li>self: Rye self management</li> <li>uninstall: Uninstalls a global tool (alias)</li> <li>version: Get or set project version</li> </ul>"},{"location":"guide/commands/#options","title":"Options","text":"<p>The toplevel <code>rye</code> command accepts the following options:</p> <ul> <li><code>--env-file</code> <code>&lt;FILE&gt;</code>: This can be supplied multiple times to make rye load   a given <code>.env</code> file.  Note that this file is not referenced to handle the   <code>RYE_HOME</code> variable which must be supplied as environment variable always.</li> </ul>"},{"location":"guide/commands/add/","title":"<code>add</code>","text":"<p>Adds a Python package to this project.  The command takes a PEP 508 requirement string but provides additional helper arguments to make this process more user friendly.  For instance instead of passing git references within the requirement string, the <code>--git</code> parameter can be used.</p> <p>If auto sync is disabled, after a dependency is added it's not automatically installed.  To do that, you need to invoke the <code>sync</code> command or pass <code>--sync</code>.  To remove a dependency again use the <code>remove</code> command.</p> <p>new in 0.26.0</p> <p>Added support for auto-sync and the <code>--sync</code> / <code>--no-sync</code> flags.</p>"},{"location":"guide/commands/add/#example","title":"Example","text":"<p>Add the latest version of a dependency that is compatible with the configured Python version:</p> <pre><code>$ rye add flask\nAdded flask&gt;=3.0.1 as regular dependency\n</code></pre> <p>Add a dependency but add an optional extra feature:</p> <pre><code>$ rye add flask --features dotenv\nAdded flask[dotenv]&gt;=3.0.1 as regular dependency\n</code></pre> <p>Add a git dependency:</p> <pre><code>$ rye add flask --git https://github.com/pallets/flask\nAdded flask @ git+https://github.com/pallets/flask as regular dependency\n</code></pre> <p>Add a local dependency:</p> <pre><code>$ rye add packagename --path path/to/packagename\nAdded packagename @ file:///path/to/packagename as regular dependency\n</code></pre>"},{"location":"guide/commands/add/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;REQUIREMENTS&gt;...</code>: The package to add as PEP 508 requirement string. e.g. 'flask==2.2.3'</li> </ul>"},{"location":"guide/commands/add/#options","title":"Options","text":"<ul> <li> <p><code>--git &lt;GIT&gt;</code>: Install the given package from this git repository</p> </li> <li> <p><code>--url &lt;URL&gt;</code>: Install the given package from this URL</p> </li> <li> <p><code>--path &lt;PATH&gt;</code>: Install the given package from this local path</p> </li> <li> <p><code>--absolute</code>: Force non interpolated absolute paths</p> </li> <li> <p><code>--tag &lt;TAG&gt;</code>: Install a specific tag</p> </li> <li> <p><code>--rev &lt;REV&gt;</code>: Update to a specific git rev</p> </li> <li> <p><code>--branch &lt;BRANCH&gt;</code>: Update to a specific git branch</p> </li> <li> <p><code>--features &lt;FEATURES&gt;</code>: Adds a dependency with a specific feature</p> </li> <li> <p><code>--dev</code>: Add this as dev dependency</p> </li> <li> <p><code>--excluded</code>: Add this as an excluded dependency that will not be installed even if it's a sub dependency</p> </li> <li> <p><code>--optional &lt;OPTIONAL&gt;</code>: Add this to an optional dependency group</p> </li> <li> <p><code>--pre</code>: Include pre-releases when finding a package version</p> </li> <li> <p><code>--pin &lt;PIN&gt;</code>: Overrides the pin operator [possible values: <code>equal</code>, <code>tilde-equal</code>, <code>greater-than-equal</code>]</p> </li> <li> <p><code>--sync</code>: Runs <code>sync</code> automatically even if auto-sync is disabled.</p> </li> <li> <p><code>--no-sync</code>: Does not run <code>sync</code> automatically even if auto-sync is enabled.</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with <code>-h</code>)</p> </li> </ul>"},{"location":"guide/commands/build/","title":"<code>build</code>","text":"<p>Builds a package for distribution.</p> <p>Under normal circumstances Rye automatically builds packages for local development.  However if you want to publish packages you need to first build them into source distributions (<code>sdist</code>) and binary/portable distributions (<code>wheel</code>).</p> <p>For more information see Building and Publishing.</p>"},{"location":"guide/commands/build/#example","title":"Example","text":"<p>This builds wheels and source distributions at once:</p> <pre><code>$ rye build\nbuilding my-project\n* Creating virtualenv isolated environment...\n* Installing packages in isolated environment... (hatchling)\n* Getting build dependencies for sdist...\n* Building sdist...\n* Building wheel from sdist\n* Creating virtualenv isolated environment...\n* Installing packages in isolated environment... (hatchling)\n* Getting build dependencies for wheel...\n* Building wheel...\nSuccessfully built my_project-0.1.0.tar.gz and my_project-0.1.0-py3-none-any.whl\n</code></pre> <p>By default you will find the artifacts in the <code>dist</code> folder.</p>"},{"location":"guide/commands/build/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/build/#options","title":"Options","text":"<ul> <li> <p><code>--sdist</code>: Build an sdist</p> </li> <li> <p><code>--wheel</code>: Build a wheel</p> </li> <li> <p><code>-a, --all</code>: Build all packages</p> </li> <li> <p><code>-p, --package &lt;PACKAGE&gt;</code>: Build a specific package</p> </li> <li> <p><code>-o, --out &lt;OUT&gt;</code>: An output directory (defaults to <code>workspace/dist</code>)</p> </li> <li> <p><code>--pyproject &lt;PYPROJECT_TOML&gt;</code>: Use this <code>pyproject.toml</code> file</p> </li> <li> <p><code>-c, --clean</code>: Clean the output directory first</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help</p> </li> </ul>"},{"location":"guide/commands/config/","title":"<code>config</code>","text":"<p>Reads or modifies the global <code>config.toml</code> file.</p> <p>The config file can be read via <code>--get</code> and it can be set with one of the set options (<code>--set</code>, <code>--set-int</code>, <code>--set-bool</code>, or <code>--unset</code>). Each of the set operations takes a key=value pair. All of these can be supplied multiple times.</p>"},{"location":"guide/commands/config/#example","title":"Example","text":"<p>This command turns on global shims:</p> <pre><code>rye config --set-bool behavior.global-python=true\n</code></pre> <p>Reads the currently set config value for global Python shims:</p> <pre><code>$ rye config --get behavior.global-python\ntrue\n</code></pre> <p>Show the path to the config:</p> <pre><code>$ rye config --show-path\n/Users/username/.rye/config.toml\n</code></pre>"},{"location":"guide/commands/config/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/config/#options","title":"Options","text":"<ul> <li> <p><code>--get &lt;GET&gt;</code>: Reads a config key</p> </li> <li> <p><code>--set &lt;SET&gt;</code>: Sets a config key to a string</p> </li> <li> <p><code>--set-int &lt;SET_INT&gt;</code>: Sets a config key to an integer</p> </li> <li> <p><code>--set-bool &lt;SET_BOOL&gt;</code>: Sets a config key to a bool</p> </li> <li> <p><code>--unset &lt;UNSET&gt;</code>: Remove a config key</p> </li> <li> <p><code>--show-path</code>: Print the path to the config</p> </li> <li> <p><code>--format &lt;FORMAT&gt;</code>: Request parseable output format rather than lines</p> <p>[possible values: json]</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/fetch/","title":"<code>fetch</code>","text":"<p>Fetches a Python interpreter for the local machine.  This command is available under the aliases <code>rye fetch</code> and <code>rye toolchain fetch</code>.</p> <p>As of Rye 0.31.0 toolchains are always fetched without build info.  This means that in the folder where toolchains are stored only the interpreter is found.  For more information see Fetching Toolchains.</p>"},{"location":"guide/commands/fetch/#example","title":"Example","text":"<p>Fetch a specific version of Python:</p> <pre><code>$ rye fetch 3.8.13\nDownloading cpython@3.8.13\nChecking checksum\nUnpacking\nDownloaded cpython@3.8.13\n</code></pre> <p>To fetch the pinned version of Python you can leave out the argument:</p> <pre><code>$ rye fetch\nDownloading cpython@3.8.17\nChecking checksum\nUnpacking\nDownloaded cpython@3.8.17\n</code></pre> <p>To fetch a version of Python into a specific location rather than rye's interpreter cache:</p> <pre><code>$ rye fetch cpython@3.9.1 --target-path=my-interpreter\n</code></pre>"},{"location":"guide/commands/fetch/#arguments","title":"Arguments","text":"<ul> <li> <p><code>[VERSION]</code>: The version of Python to fetch.</p> <p>If no version is provided, the requested version will be fetched.</p> </li> </ul>"},{"location":"guide/commands/fetch/#options","title":"Options","text":"<ul> <li> <p><code>-f, --force</code>: Fetch the Python toolchain even if it is already installed.</p> </li> <li> <p><code>--target-path</code> <code>&lt;TARGET_PATH&gt;</code>: Fetches the Python toolchain into an explicit location rather</p> </li> <li> <p><code>--build-info</code>: Fetches with build info</p> </li> <li> <p><code>--no-build-info</code>: Fetches without build info</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/fmt/","title":"<code>fmt</code>","text":"<p>new in 0.20.0</p> <p>Run the code formatter on the project.  This command is aliased to <code>format</code>.</p> <p>For more information about how to configure Ruff, have a look at the Ruff Configuration Documentation.</p>"},{"location":"guide/commands/fmt/#example","title":"Example","text":"<p>To format the code and write back to the files:</p> <pre><code>$ rye fmt\n1 file reformatted, 231 files left unchanged\n</code></pre> <p>To just check if the code needs formatting:</p> <pre><code>$ rye fmt --check\nWould reformat: src/my_project/utils.py\n1 file would be reformatted, 231 files already formatted\n</code></pre> <p>To pass extra arguments to the underlying <code>ruff</code> formatter use <code>--</code>:</p> <pre><code>$ rye fmt -- --diff\n--- src/my_project/utils.py\n+++ src/my_project/utils.py\n@@ -2,5 +2,4 @@\n\n\n def foo():\n-\n     pass\n\n1 file would be reformatted, 231 files already formatted\n</code></pre> <p>Format a specific file:</p> <pre><code>rye fmt src/foo.py\n</code></pre>"},{"location":"guide/commands/fmt/#arguments","title":"Arguments","text":"<ul> <li> <p><code>[PATHS]...</code> List of files or directories to lint.  If not supplied all files are formatted.</p> </li> <li> <p><code>[EXTRA_ARGS]...</code> Extra arguments to the formatter.</p> <p>These arguments are forwarded directly to the underlying formatter (currently always <code>ruff</code>).  Note that extra arguments must be separated from other arguments with the <code>--</code> marker.</p> </li> </ul>"},{"location":"guide/commands/fmt/#options","title":"Options","text":"<ul> <li> <p><code>-a, --all</code>: Format all packages in the workspace</p> </li> <li> <p><code>-p, --package &lt;PACKAGE&gt;</code>: Format a specific package</p> </li> <li> <p><code>--pyproject &lt;PYPROJECT_TOML&gt;</code>: Use this <code>pyproject.toml</code> file</p> </li> <li> <p><code>--check</code>: Run format in check mode</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/init/","title":"<code>init</code>","text":"<p>This command initializes a new or existing Python project with Rye.  Running it in a folder with an already existing Python project will attempt to convert it over and bootstrap Rye right there.  Otherwise it can be used to create a completely new project from scratch.</p> <p>For more information see the Basics Guide.</p>"},{"location":"guide/commands/init/#example","title":"Example","text":"<pre><code>$ rye init\nsuccess: Initialized project in /Users/john/Development/my-project.\n  Run `rye sync` to get started\n</code></pre>"},{"location":"guide/commands/init/#arguments","title":"Arguments","text":"<ul> <li><code>[PATH]</code>: Where to place the project (defaults to current path)</li> </ul>"},{"location":"guide/commands/init/#options","title":"Options","text":"<ul> <li> <p><code>--min-py &lt;MIN_PY&gt;</code>: Minimal Python version supported by this project</p> </li> <li> <p><code>-p, --py &lt;PY&gt;</code>: Python version to use for the virtualenv</p> </li> <li> <p><code>--no-readme</code>: Do not create a readme</p> </li> <li> <p><code>--no-pin</code>: Do not create .python-version file (requires-python will be used)</p> </li> <li> <p><code>--build-system &lt;BUILD_SYSTEM&gt;</code>: Which build system should be used(defaults to hatchling)?</p> <p>[possible values: <code>hatchling</code>, <code>setuptools</code>, <code>flit</code>, <code>pdm</code>, <code>maturin</code>]</p> </li> <li> <p><code>--license &lt;LICENSE&gt;</code>: Which license should be used? SPDX identifier</p> </li> <li> <p><code>--name &lt;NAME&gt;</code>: The name of the package</p> </li> <li> <p><code>--private</code>: Set \"Private :: Do Not Upload\" classifier, used for private projects</p> </li> <li> <p><code>--no-import</code>: Don't import from setup.cfg, setup.py, or requirements files</p> </li> <li> <p><code>--virtual</code>: Initialize this as a virtual package.</p> <p>A virtual package can have dependencies but is itself not installed as a Python package.  It also cannot be published.</p> </li> <li> <p><code>-r, --requirements &lt;REQUIREMENTS_FILE&gt;</code>: Requirements files to initialize pyproject.toml with</p> </li> <li> <p><code>--dev-requirements &lt;DEV_REQUIREMENTS_FILE&gt;</code>: Development requirements files to initialize pyproject.toml with</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/install/","title":"<code>install</code>","text":"<p>Installs a package as global tool.  This command has two names to <code>rye tools install</code> and <code>rye install</code>.</p> <p>This can be used to install useful Python scripts globally into it's own separated virtualenv.  For instance if you want to use the <code>black</code> formatter you can install it once.</p> <p>Normally only scripts installed by the top level dependency are installed.  In some cases you might also want to install commands from sub-dependencies.  In that case pass those dependencies with <code>--include-dep</code>.</p> <p>For more information see Tools.</p>"},{"location":"guide/commands/install/#example","title":"Example","text":"<pre><code>$ rye tools install pycowsay\nLooking in indexes: https://pypi.org/simple/\nCollecting pycowsay\n  Downloading pycowsay-0.0.0.2-py3-none-any.whl.metadata (965 bytes)\nDownloading pycowsay-0.0.0.2-py3-none-any.whl (4.0 kB)\nInstalling collected packages: pycowsay\nSuccessfully installed pycowsay-0.0.0.2\n\nInstalled scripts:\n  - pycowsay\n\n$ pycowsay \"Great Stuff\"\n\n  -----------\n&lt; Great Stuff &gt;\n  -----------\n   \\   ^__^\n    \\  (oo)\\_______\n       (__)\\       )\\/\\\n           ||----w |\n           ||     ||\n</code></pre>"},{"location":"guide/commands/install/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;REQUIREMENT&gt;...</code>: The package to install as PEP 508 requirement string.</li> </ul>"},{"location":"guide/commands/install/#options","title":"Options","text":"<ul> <li> <p><code>--git &lt;GIT&gt;</code>: Install the given package from this git repository</p> </li> <li> <p><code>--url &lt;URL&gt;</code>: Install the given package from this URL</p> </li> <li> <p><code>--path &lt;PATH&gt;</code>: Install the given package from this local path</p> </li> <li> <p><code>--absolute</code>: Force non interpolated absolute paths</p> </li> <li> <p><code>--tag &lt;TAG&gt;</code>: Install a specific tag</p> </li> <li> <p><code>--rev &lt;REV&gt;</code>: Update to a specific git rev</p> </li> <li> <p><code>--branch &lt;BRANCH&gt;</code>: Update to a specific git branch</p> </li> <li> <p><code>--features &lt;FEATURES&gt;</code>: Adds a dependency with a specific feature</p> </li> <li> <p><code>--include-dep &lt;INCLUDE_DEP&gt;</code>: Include scripts from a given dependency</p> </li> <li> <p><code>--extra-requirement &lt;EXTRA_REQUIREMENT&gt;</code>: Additional dependencies to install that are not declared by the main package</p> </li> <li> <p><code>-p, --python &lt;PYTHON&gt;</code>: Optionally the Python version to use</p> </li> <li> <p><code>-f, --force</code>: Force install the package even if it's already there</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/lint/","title":"<code>lint</code>","text":"<p>new in 0.20.0</p> <p>Run the linter on the project.  This command is aliased to <code>check</code>.  At the moment this always runs <code>ruff</code> in lint mode.</p> <p>For more information about how to configure Ruff, have a look at the Ruff Configuration Documentation.</p>"},{"location":"guide/commands/lint/#example","title":"Example","text":"<p>Run the linter:</p> <pre><code>$ rye lint\nsrc/myproject/sdk.py:1:8: F401 [*] `sys` imported but unused\nFound 1 error.\n[*] 1 fixable with the `--fix` option.\n</code></pre> <p>For issues that can be auto fixed pass <code>--fix</code>:</p> <pre><code>$ rye lint --fix\nFound 1 error (1 fixed, 0 remaining).\n</code></pre> <p>To pass extra arguments:</p> <pre><code>$ rye lint -- --watch\n</code></pre> <p>Lint a specific file:</p> <pre><code>rye lint src/foo.py\n</code></pre>"},{"location":"guide/commands/lint/#arguments","title":"Arguments","text":"<ul> <li> <p><code>[PATHS]...</code> List of files or directories to lint.  If not supplied all files are linted.</p> </li> <li> <p><code>[EXTRA_ARGS]...</code> Extra arguments to the linter.</p> <p>These arguments are forwarded directly to the underlying linter (currently always <code>ruff</code>).  Note that extra arguments must be separated from other arguments with the <code>--</code> marker.</p> </li> </ul>"},{"location":"guide/commands/lint/#options","title":"Options","text":"<ul> <li> <p><code>-a, --all</code>: Lint all packages in the workspace</p> </li> <li> <p><code>-p, --package &lt;PACKAGE&gt;</code>: Format a specific package</p> </li> <li> <p><code>--pyproject &lt;PYPROJECT_TOML&gt;</code>: Use this <code>pyproject.toml</code> file</p> </li> <li> <p><code>--fix</code>: Automatically fix fixable issues</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/list/","title":"<code>list</code>","text":"<p>new in 0.24.0</p> <p>Prints a list of installed dependencies.</p>"},{"location":"guide/commands/list/#example","title":"Example","text":"<pre><code>$ rye list\nasgiref==3.7.2\nblinker==1.7.0\nclick==8.1.7\nFlask @ git+https://github.com/pallets/flask@4df377cfbfc1d15e962a61c18920b22aebc9aa41\nitsdangerous==2.1.2\nJinja2==3.1.3\nMarkupSafe==2.1.4\nWerkzeug==3.0.1\n</code></pre>"},{"location":"guide/commands/list/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/list/#options","title":"Options","text":"<ul> <li> <p><code>--pyproject</code>: Use this <code>pyproject.toml</code> file</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/lock/","title":"<code>lock</code>","text":"<p>Updates the lockfiles without installing dependencies.  Usually one would use the <code>sync</code> command instead which both locks and installs dependencies.</p> <p>For more information see Syncing and Locking.</p>"},{"location":"guide/commands/lock/#example","title":"Example","text":"<pre><code>$ rye lock\nGenerating production lockfile: /Users/username/my-project/requirements.lock\nGenerating dev lockfile: /Users/username/my-project/requirements-dev.lock\nDone!\n</code></pre>"},{"location":"guide/commands/lock/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/lock/#options","title":"Options","text":"<ul> <li> <p><code>--update &lt;UPDATE&gt;</code>: Update a specific package</p> </li> <li> <p><code>--update-all</code>: Update all packages to the latest</p> </li> <li> <p><code>--pre</code>: Update to pre-release versions</p> </li> <li> <p><code>--features &lt;FEATURES&gt;</code>: Extras/features to enable when locking the workspace</p> </li> <li> <p><code>--all-features</code>: Enables all features</p> </li> <li> <p><code>--generate-hashes</code>: Set to true to lock with hashes in the lockfile</p> </li> <li> <p><code>--with-sources</code>: Set to true to lock with sources in the lockfile</p> </li> <li> <p><code>--pyproject &lt;PYPROJECT_TOML&gt;</code>: Use this pyproject.toml file</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/make-req/","title":"<code>make-req</code>","text":"<p>Builds and prints a PEP 508 requirement string from parts.  This is a utility command that rarely needs to be used but can help creating requirements strings for pasting into other tools.  It takes the same arguments as <code>add</code> but rather than adding the requirements into the requirements file it just spits out a formatted PEP 508 requirement string on stdout.</p>"},{"location":"guide/commands/make-req/#example","title":"Example","text":"<pre><code>$ rye make-req flask --git https://github.com/pallets/flask --rev 4df377cfbf\nflask @ git+https://github.com/pallets/flask@4df377cfbf\n</code></pre>"},{"location":"guide/commands/make-req/#arguments","title":"Arguments","text":"<ul> <li><code>[REQUIREMENTS]...</code> The package to add as PEP 508 requirement string. e.g. <code>'flask==2.2.3'</code></li> </ul>"},{"location":"guide/commands/make-req/#options","title":"Options","text":"<ul> <li> <p><code>--git &lt;GIT&gt;</code>: Install the given package from this git repository</p> </li> <li> <p><code>--url &lt;URL&gt;</code>: Install the given package from this URL</p> </li> <li> <p><code>--path &lt;PATH&gt;</code>: Install the given package from this local path</p> </li> <li> <p><code>--absolute</code>: Force non interpolated absolute paths</p> </li> <li> <p><code>--tag &lt;TAG&gt;</code>: Install a specific tag</p> </li> <li> <p><code>--rev &lt;REV&gt;</code>: Update to a specific git rev</p> </li> <li> <p><code>--branch &lt;BRANCH&gt;</code>: Update to a specific git branch</p> </li> <li> <p><code>--features &lt;FEATURES&gt;</code>: Adds a dependency with a specific feature</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/pin/","title":"<code>pin</code>","text":"<p>Pins a Python version to this project.</p> <p>This will update the <code>.python-version</code> to point to the provided version. Additionally it will update <code>requires-python</code> in the <code>pyproject.toml</code> if it's lower than the current version.  This can be disabled by passing <code>--no-update-requires-python</code>.</p> <p>Which toolchain Rye prefers depends on the Rye version.  From 0.22 onwards the latest compatible installed toolchain is picked, and only if a non existing one is found a download will be attempted.  For older versions Rye will always attempt to download the latest available if it's not installed yet unless a precise pin is selected.</p>"},{"location":"guide/commands/pin/#example","title":"Example","text":"<p>Pin a specific version of Python:</p> <pre><code>$ rye pin 3.9\npinned 3.9.18 in /Users/username/my-project\n</code></pre> <p>To issue a relaxed and not a specific pin use <code>--relaxed</code>:</p> <pre><code>$ rye pin 3.9 --relaxed\npinned 3.9 in /Users/username/my-project\n</code></pre>"},{"location":"guide/commands/pin/#arguments","title":"Arguments","text":"<ul> <li> <p><code>&lt;VERSION&gt;</code>: The version of Python to pin</p> <p>This can be a short version (3.9) or a full one (<code>cpython@3.9.18</code>).</p> </li> </ul>"},{"location":"guide/commands/pin/#options","title":"Options","text":"<ul> <li> <p><code>--relaxed</code>: Issue a relaxed pin</p> </li> <li> <p><code>--no-update-requires-python</code>: Prevent updating requires-python in the <code>pyproject.toml</code></p> </li> <li> <p><code>--pyproject &lt;PYPROJECT_TOML&gt;</code>: Use this <code>pyproject.toml</code> file</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/publish/","title":"<code>publish</code>","text":"<p>Publish packages to a package repository.  This publishes the packages which are produced by the build command.</p> <p>For more information see Building and Publishing.</p>"},{"location":"guide/commands/publish/#example","title":"Example","text":"<p>Build and publish:</p> <pre><code>$ rye build\n$ rye publish\n</code></pre> <p>Publish a specific artifact:</p> <pre><code>$ rye publish dist/example-0.1.0.tar.gz\n</code></pre>"},{"location":"guide/commands/publish/#arguments","title":"Arguments","text":"<ul> <li><code>[DIST]...</code>: The distribution files to upload to the repository (defaults to <code>&lt;workspace-root&gt;/dist/*</code>)</li> </ul>"},{"location":"guide/commands/publish/#options","title":"Options","text":"<ul> <li> <p><code>-r, --repository &lt;REPOSITORY&gt;</code>: The repository to publish to [default: <code>pypi</code>]</p> </li> <li> <p><code>--repository-url &lt;REPOSITORY_URL&gt;</code>: The repository url to publish to</p> </li> <li> <p><code>-u, --username &lt;USERNAME&gt;</code>: The username to authenticate to the repository with</p> </li> <li> <p><code>--token &lt;TOKEN&gt;</code>: An access token used for the upload</p> </li> <li> <p><code>--sign</code>: Sign files to upload using GPG</p> </li> <li> <p><code>-i, --identity &lt;IDENTITY&gt;</code>: GPG identity used to sign files</p> </li> <li> <p><code>--cert &lt;CERT&gt;</code>: Path to alternate CA bundle</p> </li> <li> <p><code>--skip-existing</code>: Skip files already published (repository must support this feature)</p> </li> <li> <p><code>-y, --yes</code>: Skip prompts</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/remove/","title":"<code>remove</code>","text":"<p>Removes a package from this project.  This removes a package from the <code>pyproject.toml</code> dependency list.</p> <p>If auto sync is disabled, after a dependency is removed it's not automatically uninstalled.  To do that, you need to invoke the <code>sync</code> command or pass <code>--sync</code>.</p> <p>new in 0.26.0</p> <p>Added support for auto-sync and the <code>--sync</code> / <code>--no-sync</code> flags.</p>"},{"location":"guide/commands/remove/#example","title":"Example","text":"<pre><code>$ rye remove flask\nRemoved flask&gt;=3.0.1\n</code></pre>"},{"location":"guide/commands/remove/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;REQUIREMENTS&gt;...</code>: The packages to remove from the project</li> </ul>"},{"location":"guide/commands/remove/#options","title":"Options","text":"<ul> <li> <p><code>--dev</code>: Remove this from dev dependencies</p> </li> <li> <p><code>--optional &lt;OPTIONAL&gt;</code>: Remove this from the optional dependency group</p> </li> <li> <p><code>--sync</code>: Runs <code>sync</code> automatically even if auto-sync is disabled.</p> </li> <li> <p><code>--no-sync</code>: Does not run <code>sync</code> automatically even if auto-sync is enabled.</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/run/","title":"<code>run</code>","text":"<p>Runs a command installed into this package.  This either runs a script or application made available in the virtualenv or a Rye specific script.</p> <p>For more information see <code>rye.tool.scripts</code>.</p>"},{"location":"guide/commands/run/#example","title":"Example","text":"<p>Run a tool from the virtualenv:</p> <pre><code>$ rye run flask\n</code></pre> <p>Invoke it without arguments to see all available scripts:</p> <pre><code>$ rye run\nflask\nhello\npython\npython3\npython3.9\n</code></pre>"},{"location":"guide/commands/run/#arguments","title":"Arguments","text":"<ul> <li><code>[COMMAND]</code>: The name of the command and the arguments to it.</li> </ul>"},{"location":"guide/commands/run/#options","title":"Options","text":"<ul> <li> <p><code>-l, --list</code>: List all commands (implied without arguments)</p> </li> <li> <p><code>--pyproject</code>: Use this <code>pyproject.toml</code> file</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/show/","title":"<code>show</code>","text":"<p>Prints the current state of the project.  This can print out information about the virtualenv, the project or workspace as well as a list of installed dependencies.</p>"},{"location":"guide/commands/show/#example","title":"Example","text":"<p>Print out the status of a project:</p> <pre><code>$ rye show\nproject: my-project\npath: /Users/username/my-project\nvenv: /Users/username/my-project/.venv\ntarget python: 3.8\nvenv python: cpython@3.9.18\nvirtual: false\n</code></pre>"},{"location":"guide/commands/show/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/show/#options","title":"Options","text":"<ul> <li> <p><code>--installed-deps</code>: Print the currently installed dependencies.</p> <p>This option is being replaced with <code>rye list</code></p> </li> <li> <p><code>--pyproject</code>: Use this <code>pyproject.toml</code> file</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/sync/","title":"<code>sync</code>","text":"<p>Updates the lockfiles and installs the dependencies into the virtualenv.</p> <p>For more information see Syncing and Locking.</p>"},{"location":"guide/commands/sync/#example","title":"Example","text":"<p>Sync the project:</p> <pre><code>$ rye sync\nReusing already existing virtualenv\nGenerating production lockfile: /Users/username/my-project/requirements.lock\nGenerating dev lockfile: /Users/username/my-project/requirements-dev.lock\nInstalling dependencies\n...\n</code></pre> <p>To sync without updating the lock file use <code>--no-lock</code>:</p> <pre><code>$ rye sync --no-lock\n</code></pre> <p>If you do not want dev dependencies to be installed use <code>--no-dev</code>:</p> <pre><code>$ rye sync --no-dev\n</code></pre> <p>To exit the sub shell run <code>exit</code>.</p>"},{"location":"guide/commands/sync/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/sync/#options","title":"Options","text":"<ul> <li> <p><code>-f, --force</code>: Force the virtualenv to be re-created</p> </li> <li> <p><code>--no-dev</code>: Do not install dev dependencies</p> </li> <li> <p><code>--no-lock</code>: Do not update the lockfile.</p> </li> <li> <p><code>--update &lt;UPDATE&gt;</code>: Update a specific package</p> </li> <li> <p><code>--update-all</code>: Update all packages to the latest</p> </li> <li> <p><code>--pre</code>: Update to pre-release versions</p> </li> <li> <p><code>--features &lt;FEATURES&gt;</code>: Extras/features to enable when locking the workspace</p> </li> <li> <p><code>--all-features</code>: Enables all features</p> </li> <li> <p><code>--generate-hashes</code>: Set to true to lock with hashes in the lockfile</p> </li> <li> <p><code>--with-sources</code>: Set to true to lock with sources in the lockfile</p> </li> <li> <p><code>--pyproject &lt;PYPROJECT_TOML&gt;</code>: Use this pyproject.toml file</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/test/","title":"<code>test</code>","text":"<p>new in 0.28.0</p> <p>Run the test suites of the project. At the moment this always runs <code>pytest</code>. Note that <code>pytest</code> must be installed into the virtual env unlike <code>ruff</code> which is used behind the scenes automatically for linting and formatting. Thus in order to use this, you need to declare <code>pytest</code> as dev dependency.</p> <pre><code>$ rye add --dev pytest\n</code></pre> <p>It's recommended to place tests in a folder called <code>tests</code> adjacent to the <code>src</code> folder of your project.</p> <p>For more information about how to use pytest, have a look at the Pytest Documentation.</p>"},{"location":"guide/commands/test/#example","title":"Example","text":"<p>Run the test suite:</p> <pre><code>$ rye test\nplatform win32 -- Python 3.11.1, pytest-8.0.2, pluggy-1.4.0\nrootdir: /Users/john/Development/stuff\nplugins: anyio-4.3.0\ncollected 1 item\n\nstuff/tests/test_batch.py .                                            [100%] \n</code></pre>"},{"location":"guide/commands/test/#arguments","title":"Arguments","text":"<ul> <li> <p><code>[EXTRA_ARGS]...</code> Extra arguments to the test runner.</p> <p>These arguments are forwarded directly to the underlying test runner (currently always <code>pytest</code>).  Note that extra arguments must be separated from other arguments with the <code>--</code> marker.</p> </li> </ul>"},{"location":"guide/commands/test/#options","title":"Options","text":"<ul> <li> <p><code>-a, --all</code>: Test all packages in the workspace</p> </li> <li> <p><code>-p, --package &lt;PACKAGE&gt;</code>: Run the test suite of a specific package</p> </li> <li> <p><code>--pyproject &lt;PYPROJECT_TOML&gt;</code>: Use this <code>pyproject.toml</code> file</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-i, --ignore</code>: Ignore the specified directory</p> </li> <li> <p><code>-s</code>, <code>--no-capture</code>: Disable stdout/stderr capture for the test runner</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/uninstall/","title":"<code>uninstall</code>","text":"<p>Uninstalls an already installed global tool.  This command has two names to <code>rye tools uninstall</code> and <code>rye uninstall</code>.</p> <p>For more information see Tools.</p>"},{"location":"guide/commands/uninstall/#example","title":"Example","text":"<pre><code>$ rye tools uninstall pycowsay\nUninstalled pycowsay\n</code></pre>"},{"location":"guide/commands/uninstall/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;NAME&gt;</code>: The package to uninstall.</li> </ul>"},{"location":"guide/commands/uninstall/#options","title":"Options","text":"<ul> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/version/","title":"<code>version</code>","text":"<p>Get or set project version.  Note that this does not refer to the version of Rye itself but the version that is set in the <code>pyproject.toml</code> file.</p>"},{"location":"guide/commands/version/#example","title":"Example","text":"<p>Get the current version:</p> <pre><code>$ rye version\n0.1.0\n</code></pre> <p>Bump the version by minor:</p> <pre><code>$ rye version -b minor\nversion bumped to 0.2.0\n</code></pre> <p>Set to a specific version:</p> <pre><code>$ rye version 1.0.0\nversion set to 1.0.0\n</code></pre>"},{"location":"guide/commands/version/#arguments","title":"Arguments","text":"<ul> <li><code>[VERSION]</code>: the version to set</li> </ul>"},{"location":"guide/commands/version/#options","title":"Options","text":"<ul> <li> <p><code>-b, --bump &lt;BUMP&gt;</code>: automatically bump the version in a specific way (<code>major</code>, <code>minor</code> or <code>patch</code>)</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/self/","title":"<code>self</code>","text":"<p>Command to manage Rye itself.</p> <ul> <li> <p><code>completion</code>: Generates a completion script for Rye.</p> </li> <li> <p><code>update</code>: Performs an update of Rye.</p> </li> <li> <p><code>uninstall</code>: Uninstalls Rye again.</p> </li> </ul>"},{"location":"guide/commands/self/completion/","title":"<code>completion</code>","text":"<p>Generates a completion script for a shell</p>"},{"location":"guide/commands/self/completion/#example","title":"Example","text":"<p>Generate a completion script for zsh and load it:</p> <pre><code>$ eval \"$(rye self completion -s zsh)\"\n</code></pre>"},{"location":"guide/commands/self/completion/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/self/completion/#options","title":"Options","text":"<ul> <li> <p><code>-s, --shell &lt;SHELL&gt;</code>: The shell to generate a completion script for (defaults to 'bash')</p> <p>[possible values: <code>bash</code>, <code>elvish</code>, <code>fish</code>, <code>powershell</code>, <code>zsh</code>, <code>nushell</code>]</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/self/uninstall/","title":"<code>uninstall</code>","text":"<p>Uninstalls rye again.  Note that this leaves a trace <code>.rye</code> folder behind with an empty <code>env</code> file.  You also need to remove the sourcing of that script from your <code>.profile</code> file.</p>"},{"location":"guide/commands/self/uninstall/#example","title":"Example","text":"<p>Uninstall rye without asking:</p> <pre><code>$ rye self uninstall --yes\n</code></pre>"},{"location":"guide/commands/self/uninstall/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/self/uninstall/#options","title":"Options","text":"<ul> <li> <p><code>-y, --yes</code>: Do not prompt and uninstall.</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/self/update/","title":"<code>update</code>","text":"<p>Performs an update of rye.</p> <p>This can install updates from the latest release binaries or trigger a manual compilation of Rye if Rust is installed.</p>"},{"location":"guide/commands/self/update/#example","title":"Example","text":"<p>Update to the latest version:</p> <pre><code>$ rye self update\n</code></pre> <p>Update (or downgrade)  to a specific version:</p> <pre><code>$ rye self update --version 0.20\n</code></pre> <p>Compile a specific revision:</p> <pre><code>$ rye self update --rev 08910bc9b3b7c72a3d3ac694c4f3412259161477\n</code></pre> <p>Compile latest development version:</p> <pre><code>$ rye self update --branch main\n</code></pre>"},{"location":"guide/commands/self/update/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/self/update/#options","title":"Options","text":"<ul> <li> <p><code>--version &lt;VERSION&gt;</code>: Update to a specific version</p> </li> <li> <p><code>--tag &lt;TAG&gt;</code>: Update to a specific tag</p> </li> <li> <p><code>--rev &lt;REV&gt;</code>: Update to a specific git rev</p> </li> <li> <p><code>--branch &lt;BRANCH&gt;</code>: Update to a specific git branch</p> </li> <li> <p><code>--force</code>: Force reinstallation</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/toolchain/","title":"<code>toolchain</code>","text":"<p>Helper utility to manage Python toolchains.  The following subcommands exist:</p> <ul> <li> <p><code>fetch</code>: fetches a toolchain</p> </li> <li> <p><code>list</code>: lists all registered toolchains</p> </li> <li> <p><code>register</code>: register a Python binary as custom toolchain</p> </li> <li> <p><code>remove</code>: removes or uninstalls a toolchain</p> </li> </ul>"},{"location":"guide/commands/toolchain/fetch/","title":"<code>fetch</code>","text":"<p>Fetches a Python interpreter for the local machine.  This command is available under the aliases <code>rye fetch</code> and <code>rye toolchain fetch</code>.</p> <p>As of Rye 0.31.0 toolchains are always fetched without build info.  This means that in the folder where toolchains are stored only the interpreter is found.  For more information see Fetching Toolchains.</p>"},{"location":"guide/commands/toolchain/fetch/#example","title":"Example","text":"<p>Fetch a specific version of Python:</p> <pre><code>$ rye fetch 3.8.13\nDownloading cpython@3.8.13\nChecking checksum\nUnpacking\nDownloaded cpython@3.8.13\n</code></pre> <p>To fetch the pinned version of Python you can leave out the argument:</p> <pre><code>$ rye fetch\nDownloading cpython@3.8.17\nChecking checksum\nUnpacking\nDownloaded cpython@3.8.17\n</code></pre> <p>To fetch a version of Python into a specific location rather than rye's interpreter cache:</p> <pre><code>$ rye fetch cpython@3.9.1 --target-path=my-interpreter\n</code></pre>"},{"location":"guide/commands/toolchain/fetch/#arguments","title":"Arguments","text":"<ul> <li> <p><code>[VERSION]</code>: The version of Python to fetch.</p> <p>If no version is provided, the requested version will be fetched.</p> </li> </ul>"},{"location":"guide/commands/toolchain/fetch/#options","title":"Options","text":"<ul> <li> <p><code>-f, --force</code>: Fetch the Python toolchain even if it is already installed.</p> </li> <li> <p><code>--target-path</code> <code>&lt;TARGET_PATH&gt;</code>: Fetches the Python toolchain into an explicit location rather</p> </li> <li> <p><code>--build-info</code>: Fetches with build info</p> </li> <li> <p><code>--no-build-info</code>: Fetches without build info</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/toolchain/list/","title":"<code>list</code>","text":"<p>List all registered toolchains.  It can list the toolchains which are installed as well as toolchains which can be downloaded if <code>--include-downloadable</code> is passed.</p>"},{"location":"guide/commands/toolchain/list/#example","title":"Example","text":"<p>List installed toolchains:</p> <pre><code>$ rye toolchain list\ncpython@3.12.1 (/Users/username/.rye/py/cpython@3.12.1/install/bin/python3)\ncpython@3.11.6 (/Users/username/.rye/py/cpython@3.11.6/install/bin/python3)\n</code></pre> <p>Lists downloadable toolchains:</p> <pre><code>$ rye toolchain list --include-downloadable\ncpython@3.12.1 (/Users/mitsuhiko/.rye/py/cpython@3.12.1/install/bin/python3)\ncpython-x86_64@3.12.1 (downloadable)\ncpython@3.11.7 (downloadable)\n...\n</code></pre>"},{"location":"guide/commands/toolchain/list/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/toolchain/list/#options","title":"Options","text":"<ul> <li> <p><code>--include-downloadable</code>: Also include non installed, but downloadable toolchains</p> </li> <li> <p><code>--format &lt;FORMAT&gt;</code>: Request parseable output format [possible values: json]</p> </li> <li> <p><code>-h, --help</code>: Print help</p> </li> </ul>"},{"location":"guide/commands/toolchain/register/","title":"<code>register</code>","text":"<p>Register a Python binary as custom toolchain.</p> <p>Rye by default will automatically download Python releases from the internet. However it's also possible to register already available local Python installations.  This allows you to use rye with self compiled Pythons.</p> <p>The name of the toolchain is auto detected (eg: <code>cpython</code>, <code>pypy</code> etc.)</p> <p>To unregister use the <code>remove</code> command.</p>"},{"location":"guide/commands/toolchain/register/#example","title":"Example","text":"<pre><code>$ rye toolchain register /opt/homebrew/Cellar/python@3.10/3.10.6_1/bin/python3.10\nRegistered /opt/homebrew/Cellar/python@3.10/3.10.6_1/bin/python3.10 as cpython@3.10.6\n</code></pre>"},{"location":"guide/commands/toolchain/register/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;PATH&gt;</code>: Path to the python binary that should be registered</li> </ul>"},{"location":"guide/commands/toolchain/register/#options","title":"Options","text":"<ul> <li> <p><code>-n, --name &lt;NAME&gt;</code>: Name of the toolchain.  If not provided a name is auto detected.</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/toolchain/remove/","title":"<code>remove</code>","text":"<p>Removes or uninstalls a toolchain.</p>"},{"location":"guide/commands/toolchain/remove/#example","title":"Example","text":"<pre><code>$ rye toolchain remove 3.9.5\nRemoved installed toolchain cpython@3.9.5\n</code></pre>"},{"location":"guide/commands/toolchain/remove/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;VERSION&gt;</code> The version of Python to remove.</li> </ul>"},{"location":"guide/commands/toolchain/remove/#options","title":"Options","text":"<ul> <li><code>-f, --force</code>: Force removal even if the toolchain is in use</li> <li><code>-h, --help</code>: Print help (see a summary with '-h')</li> </ul>"},{"location":"guide/commands/tools/","title":"<code>tools</code>","text":"<p>Helper utility to manage global tool installations.</p> <ul> <li> <p><code>install</code>: installs a tool globally.</p> </li> <li> <p><code>uninstall</code>: uninstalls a globally installed tool.</p> </li> <li> <p><code>list</code>: lists all globally installed tools.</p> </li> </ul>"},{"location":"guide/commands/tools/install/","title":"<code>install</code>","text":"<p>Installs a package as global tool.  This command has two names to <code>rye tools install</code> and <code>rye install</code>.</p> <p>This can be used to install useful Python scripts globally into it's own separated virtualenv.  For instance if you want to use the <code>black</code> formatter you can install it once.</p> <p>Normally only scripts installed by the top level dependency are installed.  In some cases you might also want to install commands from sub-dependencies.  In that case pass those dependencies with <code>--include-dep</code>.</p> <p>For more information see Tools.</p>"},{"location":"guide/commands/tools/install/#example","title":"Example","text":"<pre><code>$ rye tools install pycowsay\nLooking in indexes: https://pypi.org/simple/\nCollecting pycowsay\n  Downloading pycowsay-0.0.0.2-py3-none-any.whl.metadata (965 bytes)\nDownloading pycowsay-0.0.0.2-py3-none-any.whl (4.0 kB)\nInstalling collected packages: pycowsay\nSuccessfully installed pycowsay-0.0.0.2\n\nInstalled scripts:\n  - pycowsay\n\n$ pycowsay \"Great Stuff\"\n\n  -----------\n&lt; Great Stuff &gt;\n  -----------\n   \\   ^__^\n    \\  (oo)\\_______\n       (__)\\       )\\/\\\n           ||----w |\n           ||     ||\n</code></pre>"},{"location":"guide/commands/tools/install/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;REQUIREMENT&gt;...</code>: The package to install as PEP 508 requirement string.</li> </ul>"},{"location":"guide/commands/tools/install/#options","title":"Options","text":"<ul> <li> <p><code>--git &lt;GIT&gt;</code>: Install the given package from this git repository</p> </li> <li> <p><code>--url &lt;URL&gt;</code>: Install the given package from this URL</p> </li> <li> <p><code>--path &lt;PATH&gt;</code>: Install the given package from this local path</p> </li> <li> <p><code>--absolute</code>: Force non interpolated absolute paths</p> </li> <li> <p><code>--tag &lt;TAG&gt;</code>: Install a specific tag</p> </li> <li> <p><code>--rev &lt;REV&gt;</code>: Update to a specific git rev</p> </li> <li> <p><code>--branch &lt;BRANCH&gt;</code>: Update to a specific git branch</p> </li> <li> <p><code>--features &lt;FEATURES&gt;</code>: Adds a dependency with a specific feature</p> </li> <li> <p><code>--include-dep &lt;INCLUDE_DEP&gt;</code>: Include scripts from a given dependency</p> </li> <li> <p><code>--extra-requirement &lt;EXTRA_REQUIREMENT&gt;</code>: Additional dependencies to install that are not declared by the main package</p> </li> <li> <p><code>-p, --python &lt;PYTHON&gt;</code>: Optionally the Python version to use</p> </li> <li> <p><code>-f, --force</code>: Force install the package even if it's already there</p> </li> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/commands/tools/list/","title":"<code>list</code>","text":"<p>Lists all already installed global tools.</p> <p>For more information see Tools.</p>"},{"location":"guide/commands/tools/list/#example","title":"Example","text":"<p>List installed tools:</p> <pre><code>$ rye tools list\npycowsay\n</code></pre> <p>List installed tools with version:</p> <pre><code>$ rye tools list --include-version\npycowsay 0.0.0.2 (cpython@3.12.1)\n</code></pre>"},{"location":"guide/commands/tools/list/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"guide/commands/tools/list/#options","title":"Options","text":"<ul> <li><code>-s, --include-scripts</code>: Show all the scripts installed by the tools</li> </ul> <p>changed in 0.26.0</p> <p>Renamed from <code>-i, --include-scripts</code> to <code>-s, --include-scripts</code>.</p> <ul> <li><code>-v, --include-version</code>: Show the version of tools</li> </ul> <p>changed in 0.26.0</p> <p>Renamed from <code>-v, --version-show</code> to <code>-v, --include-version</code>.</p> <ul> <li><code>-h, --help</code>: Print help</li> </ul>"},{"location":"guide/commands/tools/uninstall/","title":"<code>uninstall</code>","text":"<p>Uninstalls an already installed global tool.  This command has two names to <code>rye tools uninstall</code> and <code>rye uninstall</code>.</p> <p>For more information see Tools.</p>"},{"location":"guide/commands/tools/uninstall/#example","title":"Example","text":"<pre><code>$ rye tools uninstall pycowsay\nUninstalled pycowsay\n</code></pre>"},{"location":"guide/commands/tools/uninstall/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;NAME&gt;</code>: The package to uninstall.</li> </ul>"},{"location":"guide/commands/tools/uninstall/#options","title":"Options","text":"<ul> <li> <p><code>-v, --verbose</code>: Enables verbose diagnostics</p> </li> <li> <p><code>-q, --quiet</code>: Turns off all output</p> </li> <li> <p><code>-h, --help</code>: Print help (see a summary with '-h')</p> </li> </ul>"},{"location":"guide/toolchains/","title":"Toolchain Management","text":"<p>Rye is unique in that it does not use system Python installations.  Instead it downloads and manages Python installations itself (called toolchains).  Today there are three types of toolchains supported by Rye and they require some understanding:</p> <ul> <li>Portable CPython: Rye will itself download portable builds of CPython   for most of its needs.  These are fetched from   indygreg/python-build-standalone</li> <li>Official PyPy Builds: PyPy is supported from the official release builds.</li> <li>Custom Local Toolchains: locally installed Python interpreters can be   registered with Rye.  Afterwards, they can be used with any Rye managed project.</li> </ul>"},{"location":"guide/toolchains/#pinning-toolchains","title":"Pinning Toolchains","text":"<p>To make a project use a specific toolchain write the name of the toolchain into the <code>.python-version</code> file or use the <code>pin</code> command.  For pinning <code>cpython</code> the <code>cpython@</code> prefix can be omitted.</p> <pre><code>rye pin cpython@3.11.4\n</code></pre> <p>Pinning a downloadable version means that Rye will automatically fetch it when necessary. By default, toolchains are pinned to a precise version.  This means that even if you write <code>rye pin cpython@3.11</code>, a very specific version of cpython is written into the <code>.python-version</code> file.  With Rye 0.5.0 onwards it's possible to perform \"relaxed\" pins:</p> <pre><code>rye pin --relaxed cpython@3.11\n</code></pre> <p>This will then persist <code>3.11</code> in the <code>.python-version</code> file and Rye will use the latest available compatible version for the virtual environment.</p> <p>changed in 0.5.0</p> <p>Relaxed pinning with <code>rye pin --relaxed</code> was added.</p>"},{"location":"guide/toolchains/#non-native-architectures","title":"Non Native Architectures","text":"<p>new in 0.14.0</p> <p>Support for fetching and pinning of non-native architectures was added.</p> <p>By default, the pin is for the architecture of the running machine.  This means that if you pin <code>cpython@3.11</code> on a mac with aarch64 architecture, you will use a cpython interpreter of that CPU architecture.  A different architecture can be selected by adding <code>-{arch}</code> to the python family name.  So for instance to force a <code>x86_64</code> version you need to pin like this:</p> <pre><code>rye pin cpython-x86_64@3.11\n</code></pre> <p>Note that such custom pins are not reflected in <code>pyproject.toml</code> but only <code>.python-version</code>.</p>"},{"location":"guide/toolchains/#listing-toolchains","title":"Listing Toolchains","text":"<p>To see which toolchains are installed, <code>rye toolchain list</code> prints a list:</p> <p><pre><code>rye toolchain list\n</code></pre> <pre><code>cpython@3.11.1 (C:\\Users\\armin\\.rye\\py\\cpython@3.11.1\\install\\python.exe)\npypy@3.9.16 (C:\\Users\\armin\\.rye\\py\\pypy@3.9.16\\python.exe)\n</code></pre></p> <p>To see which toolchains can be installed, additionally pass the <code>--include-downloadable</code>:</p> <pre><code>rye toolchain list --include-downloadable\n</code></pre>"},{"location":"guide/toolchains/#fetching-toolchains","title":"Fetching Toolchains","text":"<p>Generally Rye automatically downloads toolchains, but they can be explicitly fetched with <code>rye toolchain fetch</code> (also aliased to <code>rye fetch</code>):</p> <pre><code>rye toolchain fetch cpython@3.8.5\n</code></pre> <p>Starting with Rye 0.19.0 the argument to <code>fetch</code> is inferred from the current pin.  This means you can also fetch as follows:</p> <pre><code>rye pin 3.10\nrye fetch\n</code></pre> <p>Toolchains are fetched from two sources:</p> <ul> <li>Indygreg's Portable Python Builds for CPython</li> <li>PyPy.org for PyPy</li> </ul> <p>You can also fetch toolchains into a specific location.  In this case the interpreter is not stored where Rye normally consults it, but in a specific location.  Rye will then not be able to use it unless it's manually registered.  This however can be useful for debugging or advanced setups:</p> <pre><code>rye toolchain fetch cpython@3.8.5 --target-path=my-interpreter\n</code></pre> <p>If you want to use rye interpreter fetching without installing rye, you might want to export the <code>RYE_NO_AUTO_INSTALL</code> environment variable and set it to <code>1</code> as otherwise the installer will kick in.</p>"},{"location":"guide/toolchains/#registering-toolchains","title":"Registering Toolchains","text":"<p>Additionally, it's possible to register an external toolchain with the <code>rye toolchain register</code> command.</p> <pre><code>rye toolchain register /path/to/python\n</code></pre> <p>The name of the toolchain is picked based on the interpreter.  For instance linking a regular cpython installation will be called <code>cpython@version</code>, whereas linking pypy would show up as <code>pypy@version</code>.  From Rye 0.5.0 onwards <code>-dbg</code> is appended to the name of the toolchain if it's a debug build.  To override the name you can pass <code>--name</code>:</p> <pre><code>rye toolchain register --name=custom /path/to/python\n</code></pre>"},{"location":"guide/toolchains/#removing-toolchains","title":"Removing Toolchains","text":"<p>To remove an already fetched toolchain run <code>rye toolchain remove</code>.  Note that this also works for linked toolchains:</p> <pre><code>rye toolchain remove cpython@3.8.5\n</code></pre> <p>Warning</p> <p>Removing an actively used toolchain will render the virtualenvs that refer to use broken.</p>"},{"location":"guide/toolchains/#build-info","title":"Build Info","text":"<p>new in 0.31.0</p> <p>Prior to Rye 0.31.0 the Python installations were fetched with build infos.  You can see this because the folder structure in <code>~/.rye/py/INTERPRETER</code> is a bit different.  Rather than finding <code>cpython@3.8.5/bin/python3</code> there you will instead have an extra <code>install</code> folder (<code>cpython@3.8.5/install/bin/python3</code>) alongside a <code>build</code> folder containing the intermediate build outputs.  Starting with 0.31.0 the build info is removed by default.  If you want to get it back, you can explicitly fetch with <code>--build-info</code> or you can set the <code>behavior.fetch-with-build-info</code> config flag to true:</p> <pre><code>rye config --set-bool behavior.fetch-with-build-info=true\n</code></pre>"},{"location":"guide/toolchains/cpython/","title":"Portable CPython","text":"<p>Rye is capable (and prefers) to download its own Python distribution over what you might already have on your computer.  For CPython, the indygreg/python-build-standalone builds from the PyOxidizer project are used.</p> <p>The motivation for this is that it makes it easy to switch between Python versions, to have a common experience across different Rye users and to avoid odd bugs caused by changes in behavior.</p> <p>Unfortunately Python itself does not release binaries (or the right types of binaries) for all operating systems which is why Rye leverages the portable Python builds from PyOxidizer.</p> <p>Unlike many other Python versions you can install on your computer are non-portable which means that if you move them to a new location on your machine, or you copy it onto another computer (even with the same operating system) they will no longer run.  This is undesirable for what Rye wants to do. For one we want the same experience for any of the Python developers, no matter which operating system they used.  Secondly we want to enable self-contained Python builds later, which requires that the Python installation is portable.</p> <p>To achieve this, the Python builds we use come with some changes that are different from a regular Python build.</p>"},{"location":"guide/toolchains/cpython/#limitations","title":"Limitations","text":"<p>The following changes to a regular Python versions you should be aware of:</p> <ul> <li> <p><code>libedit</code> instead of <code>readline</code>: unfortunately <code>readline</code> is GPLv3 licensed   and this is a hazard for redistributions.  As such, the portable Python   builds link against the more freely licensed <code>libedit</code> instead.</p> </li> <li> <p><code>dbm.gnu</code> is unavailable.  This is a rather uncommonly used module and the   standard library provides alternatives.</p> </li> </ul> <p>Additionally due to how these builds are created, there are some other quirks you might run into related to terminal support or TKinter.  Some of these issues are collected in the FAQ.  Additionally, the Python Standalone Builds have a Behavior Quirks page.</p>"},{"location":"guide/toolchains/cpython/#sources","title":"Sources","text":"<p>Portable CPython builds are downloaded from GitHub (indygreg/python-build-standalone/releases) and SHA256 hashes are generally validated.  Some older versions might not have hashes available in which case the validation is skipped.</p>"},{"location":"guide/toolchains/cpython/#usage","title":"Usage","text":"<p>When you pin a Python version to <code>cpython@major.minor.patch</code> (or just <code>major.minor.patch</code>) then Rye will automatically download the right version for you whenever it is needed.  If a custom toolchain has already been registered with that name and version, that this is used instead.</p>"},{"location":"guide/toolchains/pypy/","title":"PyPy","text":"<p>PyPy is supported as alternative Python distribution. Like the portable CPython builds it's downloaded automatically.  The name for PyPy distributions is <code>pypy</code>.</p>"},{"location":"guide/toolchains/pypy/#limitations","title":"Limitations","text":"<p>PyPy has some limitations compared to regular Python builds when it comes to working with Rye.  Most specifically PyPy uses some internal pypi dependencies and you might notice warnings show up when syching.  PyPy also lags behind regular Python installations quite a bit these days so you likely need to target older Python packages.</p>"},{"location":"guide/toolchains/pypy/#sources","title":"Sources","text":"<p>PyPy builds are downloaded from downloads.python.org.</p>"},{"location":"guide/toolchains/pypy/#usage","title":"Usage","text":"<p>When you pin a Python version to <code>pypy@major.minor.patch</code> then Rye will automatically download the right version for you whenever it is needed.  If a custom toolchain has already been registered with that name and version, that this is used instead.  Note that the version refers to the PyPy CPython version.</p> <p>That means for instance that PyPy 7.3.11 is identified as <code>pypy@3.9.16</code> as this is the Python version it provides.  As PyPy also lacks builds for some CPU architectures, not all platforms might provide the right PyPy versions. </p>"}]}